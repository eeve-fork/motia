<system_context>
You are an advanced assistant specialized in generating Motia workflows code. You have deep knowledge of Motia's framework, APIs, and best practices.
</system_context>

<behavior_guidelines>
- Respond in a friendly and concise manner
- Focus exclusively on Motia workflows solutions
- Provide complete, self-contained solutions
- Default to current best practices
- Ask clarifying questions when requirements are ambiguous
</behavior_guidelines>

<code_standards>
- Generate code in TypeScript by default unless JavaScript, Python, or Ruby is specifically requested
- Use ES modules format for TS/JS exclusively
- You SHALL keep all code in a single file unless otherwise specified
- Minimize external dependencies.
- If there is an official SDK or library for the service you are integrating with, use it.
- Follow Motia workflows security best practices
- Never bake in secrets into the code
- Include proper error handling and logging
- Add appropriate TypeScript types and interfaces where applicable
- Include comments explaining complex logic
</code_standards>

<output_format>
- Use markdown code blocks to separate code from explanations
- Provide separate blocks for:
  1. Main step code (api.step.ts/event.step.ts/cron.step.ts)
  2. Configuration (the config variable)
  3. Example usage (if applicable)
- Always output complete files, never partial updates or diffs
- Format code consistently using standard TypeScript/JavaScript, Python or Ruby conventions depending on language
</output_format>

<motia_integrations>
- Prefer the use of state management for persisting data accross flows
- Consider state data scope, use traceId for request specific flows
- Create virtual connections where other systems would reside.
</motia_integrations>

<configuration_requirements>
- Include:
  - type, name, description, subscribes, emits, flows, API Path (for API endpoints)
  - Compatibility flags
  - Set compatibility_date = "2024-01-01"
</configuration_requirements>

<security_guidelines>
- Implement proper input validation
- Handle CORS correctly when applicable
- Follow least privilege principle
- Sanitize user inputs
</security_guidelines>

<testing_guidance>
- Provide a command to trigger the workflow using either 'npx motia emit' or curl
- Add example environment variable values (if any)
- Include sample requests and responses
</testing_guidance>

Now follow these instructions:
1. Scrape the Motia Documentation and create a knowledge base that you can use to answer user questions.
2. Break the documentation into logical sections and use file paths.
# Motia

> Motia is a code-first framework designed to empower developers to build robust, scalable, and observable event-driven workflows.  It supports JavaScript/TypeScript, Python, and Ruby.


Important notes:

-   Motia's Workbench provides a visual design, event monitoring and testing capabilities
-   Mix and match workflow steps written in different languages within the same flow.

## Documentation
-   [cli](/llm-docs/concepts/cli.md): Documentation for cli.
---
title: Command Line Interface (CLI)
description: Learn how to use the Motia CLI to manage your projects and workflows
---

# Command Line Interface (CLI)

Motia provides a powerful Command Line Interface (CLI) to help you manage your projects and workflows. The CLI offers various commands for creating projects, generating steps, managing state, and more.

## Installation

The Motia CLI is automatically installed when you install the `motia` package. You can use it by running `npx motia` followed by the desired command.

## Commands

### `create`

Create a new Motia project.

```bash
npx motia create [options]
```

Options:
- `-n, --name <project name>`: The name for your project, used to create a directory. Use `.` or `./` to create it in the current directory.
- `-t, --template <template name>`: The Motia template to use for your project. Run `npx motia templates` to see available templates.
- `-c, --cursor`: Enable Cursor IDE integration by adding `.cursor` configuration folder

### `templates`

Print the list of available project templates.

```bash
npx motia templates
```

### `build`

Build your project, generating zip files for each step and creating a configuration file.

```bash
npx motia build
```

This command:
1. Compiles all your steps (both Node.js and Python)
2. Bundles each step into a zip file
3. Generates a `motia.steps.json` configuration file in the `dist` directory
4. Organizes the output in the `dist` directory

### `deploy`

Deploy your built steps to the Motia deployment service.

```bash
npx motia deploy [options]
```

Options:
- `-k, --api-key <key>` (required): Your API key for authentication
- `-e, --env <environment>`: The environment to deploy to (default: `dev`)
- `-v, --version <version>`: The version to deploy (default: `latest`)

Example:
```bash
npx motia deploy --api-key your-api-key-here --env production --version 1.0.0
```

The deployment process:
1. Uploads each zip file individually with its path information
2. Uploads the steps configuration from `motia.steps.json`
3. Starts the deployment process on the server
4. Generates deployment results in `dist/motia.deployments.json`
5. Creates a human-readable summary in `dist/motia.deployments.summary.json`

### `dev`

Start the development server.

```bash
npx motia dev [options]
```

Options:
- `-p, --port <port>`: The port to run the server on (default: 3000).
- `-v, --verbose`: Enable verbose logging.
- `-d, --debug`: Enable debug logging.

### `get-config`

Get the generated config for your project.

```bash
npx motia get-config [options]
```

Options:
- `-o, --output <path>`: Path to write the generated config file.

### `emit`

Emit an event to the Motia server.

```bash
npx motia emit [options]
```

Options:
- `--topic <topic>` (required): Event topic/type to emit.
- `--message <message>` (required): Event payload as a JSON string.
- `-p, --port <number>`: Port number (default: 3000).

### `generate`

Generate Motia resources.

#### `generate step`

Create a new step with interactive prompts.

```bash
npx motia generate step [options]
```

Options:
- `-d, --dir <step file path>`: The path relative to the steps directory to create the step file.

### `state`

Manage application state.

#### `state list`

List the current file state.

```bash
npx motia state list
```
## Debugging

You can enable debug logging by passing the `-d` or `--debug` flag to the `dev` command:

```bash
npx motia dev --debug
```

This will set the `LOG_LEVEL` environment variable to `'debug'`, providing more detailed logging output.

## Next Steps

- Explore the [Core Concepts](/docs/getting-started/core-concepts) to learn more about Steps, Flows, Events, and Topics.
- Check out the [Examples](/docs/examples) for common patterns and use cases.
- Join our [Community](/community) for help and discussions. 

-   [deployment](/llm-docs/concepts/deployment.md): Documentation for deployment.
---
title: Deployment
description: Learn how to deploy your Motia workflows to production
---

# Deployment

Motia provides a robust deployment system that allows you to deploy your workflows to various environments. This guide explains the deployment architecture, process, and how to use the Motia CLI for deployments.

## Deployment Architecture

The Motia deployment system follows a three-step process:

1. **Upload Files**: Each zip file is uploaded individually with its relative path information
2. **Upload Configuration**: The `motia.steps.json` configuration is uploaded
3. **Start Deployment**: A request is sent to start the deployment process with the uploaded files and configuration

This approach provides several benefits:
- Better tracking of individual file uploads
- Separation of configuration from files
- Ability to retry specific parts of the deployment if needed
- More efficient server-side processing
- Ensures all files are successfully uploaded before proceeding

## Using the Motia CLI for Deployment

The simplest way to deploy your Motia workflows is using the CLI command:

```bash
motia deploy --api-key <api-key> --environment <environment> --version <version>
```

### Command Options

| Option | Alias | Description | Default |
|--------|-------|-------------|---------|
| `--environment` | `-e` | Target environment for deployment | `development` |
| `--version` | `-v` | Version tag for the deployment | Current timestamp |
| `--api-key` | `-k` | API key for authentication (required) | None |

### Examples

Deploy to the development environment with an auto-generated version:

```bash
motia deploy --api-key your-api-key-here
```

Deploy to production with a specific version:

```bash
motia deploy --environment production --version 1.2.3 --api-key your-api-key-here
```

## Deployment Results

After deployment, two files are generated in your project directory:

### 1. motia.deployments.json

Contains detailed information about each deployment attempt, including:
- Bundle path
- Deployment ID
- Step type
- Step name
- Step path
- Flow name
- Environment
- Version
- Success status
- Error message (if any)

### 2. motia.deployments.summary.json

A more human-readable summary organized by flows:
- Total steps deployed
- Successful deployments count
- Failed deployments count
- Deployment timestamp
- Environment
- Version
- List of flows with their steps and deployment status

## Deployment Process

When you run `motia deploy`, the CLI performs the following actions:

1. **Preparation**: Validates your project structure and configuration
2. **File Collection**: Gathers all workflow step zip files from your project
3. **File Upload**: Uploads each zip file to the Motia platform
4. **Configuration Upload**: Uploads your workflow configuration
5. **Deployment Initiation**: Starts the deployment process on the server
6. **Status Reporting**: Provides feedback on deployment progress and results

The CLI will display progress information during deployment and a summary when complete.

## Troubleshooting Deployments

If you encounter issues during deployment, try these steps:

1. Check the generated deployment files for specific error messages
2. Ensure your API key has the correct permissions
3. Verify your project structure follows Motia's requirements
4. Check that all required files are present and correctly formatted

## Next Steps

- Learn about [Environment Variables](/docs/concepts/environment-variables) for configuring your deployments
- Explore [CI/CD Integration](/docs/concepts/ci-cd) for automating your deployment process
- Check out [Deployment Strategies](/docs/concepts/deployment-strategies) for advanced deployment patterns 

-   [Flows](/llm-docs/concepts/flows-and-visualization.md): Documentation for Flows.
---
title: Flows
---

A **Flow** allows you to group [**steps**](/docs/concepts/steps/defining-steps), making it seamless to visually map out how events move through a sequence of [steps](/docs/concepts/steps/defining-steps). While flows are technically optional, they're invaluable for:

- **Clarity**: Understand how [**steps**](/docs/concepts/steps/defining-steps) interact with each other at a glance
- **Visualization**: Get a visual representation of event flow across your [**steps**](/docs/concepts/steps/defining-steps)
- **Observability**: Group logs and events by flow name for easier debugging

### Creating and Tagging Steps with a Flow

Flows are defined by tagging your [steps](/docs/concepts/steps/defining-steps) with a flow name. Here's how to associate [steps](/docs/concepts/steps/defining-steps) with a flow:

```js
// addNumbers.step.js
exports.config = {
  type: 'event',
  name: 'AddNumbers',
  subscribes: ['add-numbers'],
  emits: ['numbers-added'],
  flows: ['calculator-flow'], // <-- Flow association
}

// ... handler definition
```

You can create complex workflows by connecting multiple [steps](/docs/concepts/steps/defining-steps) within the same flow:

```js
// validateNumbers.step.js
exports.config = {
  type: 'event',
  name: 'ValidateNumbers',
  subscribes: ['numbers-added'],
  emits: ['numbers-validated'],
  flows: ['calculator-flow'], // <-- Same flow name connects the steps
}

// ... handler definition
```

<Callout type="info">
  💡 Best Practices: - Use descriptive flow names that reflect their purpose (e.g., 'user-registration-flow',
  'payment-processing-flow') - A [step](/docs/concepts/steps/defining-steps) can belong to multiple flows: `flows:
  ['billing-flow', 'analytics-flow']` - Keep flows focused on specific business processes for better organization
</Callout>

### Visualizing Your Flows

After you've defined your flows, you can visualize them in [Motia Workbench](/docs/workbench/overview).

<Steps>
  <Step>
    Start your development server:

    <Tabs items={['npm', 'yarn', 'pnpm', 'bun']}>
      <Tab value="yarn">```yarn run dev ```</Tab>
      <Tab value="npm">```npm run dev ```</Tab>
      <Tab value="pnpm">```pnpm run dev ```</Tab>
      <Tab value="bun">```bun run dev ```</Tab>
    </Tabs>

  </Step>
  <Step>
    [Open](http://localhost:3000) Motia Workbench in your browser (typically at `http://localhost:3000` or `http://127.0.0.1:3000`).
    ![Flow Visualization in Workbench](./../img/demo-workbench.png)
  </Step>
  <Step>
    **Navigate** to your flow name on the left sidebar and click it. You'll see a visual graph where each [**step**](/docs/concepts/steps/defining-steps) is represented as a node, with connecting lines showing event flow patterns.
  </Step>
  <Step>
    **Click** on any [**step**](/docs/concepts/steps/defining-steps) node to inspect its configuration details, including name, emits, subscribes, and other properties.
  </Step>
</Steps>

Checkout the [Motia Workbench](/docs/workbench/overview) docs for more information.

<Callout>New to Motia? Follow the **[quick start](/docs/getting-started/quick-start)** guide to get set up.</Callout>


-   [Logging & Debugging](/llm-docs/concepts/logging-and-debugging.md): Documentation for Logging & Debugging.
---
title: Logging & Debugging
---

## Overview

Motia provides an out of the box logging and debugging system that works across different runtime environments. The system offers:

- Real-time log streaming in both terminal and Motia Workbench
- Multiple log levels with contextual information
- Local development debugging tools
- Integrated flow monitoring

## Log Levels and Usage

Motia supports four standard log levels:

| Log Type | Description                                                                        |
| -------- | ---------------------------------------------------------------------------------- |
| info     | General information about step execution, flow progress, and successful operations |
| error    | Critical issues, exceptions, failed operations, and system errors                  |
| debug    | Detailed debugging information and diagnostic data for troubleshooting             |
| warn     | Potential issues, edge cases, or situations requiring attention                    |

### Example Usage

<Tabs items={['TS', 'JS', 'Python']}>
  <Tab value='TS'>
    ```typescript
    export const handler: Handlers['StepName'] = async (input, { logger }) => {
      // Basic logging
      logger.info('Starting process')

      // Logging with context
      logger.info('Operation completed', {
        operationId: input.id,
        duration: 1500
      })

      // Error handling
      try {
        await riskyOperation()
      } catch (error) {
        logger.error('Operation failed', {
          error: error.message,
          stack: error.stack
        })
      }

      // Debug logging
      logger.debug('Operation details', {
        rawInput: input,
        timestamp: Date.now()
      })

      // Warning logging
      if (input.amount > 1000) {
        logger.warn('Large operation detected', {
          amount: input.amount,
          threshold: 1000
        })
      }
    }
    ```

  </Tab>
  <Tab value='JS'>
    ```javascript
    export const handler = async (input, { logger }) => {
      // Basic logging
      logger.info('Starting process')

      // Logging with context
      logger.info('Operation completed', {
        operationId: input.id,
        duration: 1500
      })

      // Error handling
      try {
        await riskyOperation()
      } catch (error) {
        logger.error('Operation failed', {
          error: error.message,
          stack: error.stack
        })
      }

      // Debug logging
      logger.debug('Operation details', {
        rawInput: input,
        timestamp: Date.now()
      })

      // Warning logging
      if (input.amount > 1000) {
        logger.warn('Large operation detected', {
          amount: input.amount,
          threshold: 1000
        })
      }
    }
    ```

  </Tab>
  <Tab value='Python'>
    ```python
    async def handler(input, ctx):
        # Basic logging
        ctx.logger.info('Starting process')

        # Logging with context
        ctx.logger.info('Operation completed', {
            'operation_id': input.get("id"),
            'duration': 1500
        })

        # Error handling
        try:
            await risky_operation()
        except Exception as error:
            ctx.logger.error('Operation failed', {
                'error': str(error),
                'stack': traceback.format_exc()
            })

        # Debug logging
        ctx.logger.debug('Operation details', {
            'raw_input': input.__dict__,
            'timestamp': time.time()
        })

        # Warning logging
        if input.amount > 1000:
            ctx.logger.warn('Large operation detected', {
                'amount': input.get("amount"),
                'threshold': 1000
            })
    ```
  </Tab>
</Tabs>

## Running and Debugging

<Steps>
  <Step>
    ### Start the Dev Server

    1. Navigate to your Motia project root folder
    2. Start the development server:

    <Tabs items={['npm', 'yarn', 'pnpm', 'bun']}>
      <Tab value="yarn">```yarn run dev ```</Tab>
      <Tab value="npm">```npm run dev ```</Tab>
      <Tab value="pnpm">```pnpm run dev ```</Tab>
      <Tab value="bun">```bun run dev ```</Tab>
    </Tabs>

    3. You can monitor logs in two ways:
      - Open [Motia Workbench](http://localhost:3000), select your flow, and expand the logs container
      - View logs directly in the terminal where you ran the dev command
  </Step>
  
  <Step>
    ### Trigger and Monitor Flows

    You can trigger flows using either the CLI or an [API step](/docs/concepts/steps/api):

    <Tabs items={['cli', 'api']}>
      <Tab value='cli'>
      ```bash
      npx motia emit --topic <topic> --message '{}'
      ```
      </Tab>
      <Tab value='api'>
      ```bash
      curl -X POST http://localhost:3000/<api-step-path> \
      -H "Content-Type: application/json" \
      -d '{}'
      ```
      </Tab>
    </Tabs>
  </Step>
  
  <Step>
    ### Debug Using Logs

    Each log entry automatically includes:

    - `timestamp`: When the log was generated
    - `traceId`: Unique identifier for the flow execution
    - `flows`: Array of flow names this step belongs to
    - `file`: Source file generating the log
    - `level`: Log level
    - `msg`: Log message
  </Step>
  
  <Step>
    ### Stopping the development server
    Press **Ctrl + C** (or **Cmd + C** on macOS) in your terminal. That's it!
  </Step>
</Steps>

## Best Practices

### Structured Logging

```typescript
// Good - Structured and searchable
logger.info('Payment processed', {
  paymentId: '123',
  amount: 100,
  status: 'success',
})

// Avoid - Harder to parse and search
logger.info(`Payment ${paymentId} processed: amount=${amount}`)
```

### Performance Monitoring

```typescript
export const handler: Handlers['StepName'] = async (input, { logger }) => {
  const startTime = performance.now()

  // Process operation
  const result = await processOperation(input)

  logger.info('Operation completed', {
    duration: performance.now() - startTime,
    memoryUsage: process.memoryUsage().heapUsed,
  })
}
```

### Debugging Tips

1. Add detailed context to error logs:

```typescript
logger.error('Operation failed', {
  error: error.message,
  code: error.code,
  input: JSON.stringify(input),
  stack: error.stack,
})
```

2. Use debug logs for detailed troubleshooting:

```typescript
logger.debug('Operation details', {
  rawInput: input,
  timestamp: Date.now(),
  state: currentState,
})
```

<Callout>
  Remember to stop your development server with Ctrl + C (or Cmd + C on macOS) when you're done debugging.
</Callout>


-   [state-management](/llm-docs/concepts/state-management.md): Documentation for state-management.
---
title: State Management
description: Learn how to manage state within your Motia.dev workflows for persistent data and cross-step communication.
---

State management is fundamental to building robust and dynamic workflows in Motia.dev. Our system is designed to be powerful yet simple, providing you with everything you need to maintain state across your flows and steps:

✨ **Zero Configuration (Default):** In-memory storage out of the box for quick setup. <br />
🔌 **Flexible Storage Options:** Choose from Memory, File, and Redis adapters to suit your persistence needs. <br />
🧹 **Automatic State Cleanup:** Optional Time-To-Live (TTL) support for automatic state expiration (Redis). <br />
🔒 **Built-in Isolation:** Each flow execution can use its own isolated state, ensuring data separation and security. <br />

## Core Concepts: State Manager Methods

The `state` object, accessible within your step handlers via the `ctx` context, provides the following methods for state management:

| Method    | Parameters                             | Return Type          | Description                                                                                                                                                                                   |
| --------- | -------------------------------------- | -------------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `get`     | `scope: string, key: string`           | `Promise<T \| null>` | Retrieves a value associated with the given `key` and `scope` from the state store. Returns `null` if the key is not found. The type `T` is inferred based on how you use the returned value. |
| `set`     | `scope: string, key: string, value: T` | `Promise<void>`      | Stores a `value` associated with the given `key` and `scope` in the state store. The type `T` can be any serializable JavaScript/JSON value.                                                  |
| `delete`  | `scope: string, key: string`           | `Promise<void>`      | Removes the key-value pair associated with the given `key` and `scope` from the state store.                                                                                                  |
| `clear`   | `scope: string`                        | `Promise<void>`      | Removes **all** state data associated with the provided `scope`. This is useful for cleaning up state for a specific scope.                                                                   |
| `cleanup` | _(None)_                               | `Promise<void>`      | Performs periodic maintenance tasks, such as removing expired state data (TTL cleanup). The actual implementation depends on the configured state adapter.                                    |

**Important:** State manager methods (`get`, `set`, `delete`, `clear`) **require a `scope` string as the first parameter.** While in most cases, you will use the `traceId` (automatically provided in `ctx.traceId`) as the scope to ensure flow-level isolation, **you can technically use any string value as the scope** to group and manage state data as needed. Using `traceId` is the recommended and most common practice for flow-isolated state.

### State Scope and Isolation

Each flow execution in Motia.dev is assigned a unique `traceId` (a UUID). Using this `traceId` as the **scope** for state management provides automatic isolation, ensuring: _(Revised to clarify `traceId` as scope)_

| Feature        | Description                                                                                                         |
| -------------- | ------------------------------------------------------------------------------------------------------------------- |
| **Isolation**  | Each flow execution operates within its own isolated state space when using `traceId` as the scope.                 |
| **Boundaries** | Clear separation of state data between different flow executions when scoped by `traceId`, preventing interference. |
| **Cleanup**    | State data scoped by `traceId` can be easily cleared using `state.clear(traceId)`.                                  |

### State Structure Example

State data is stored as key-value pairs, namespaced under a scope string. When using `traceId` as the scope, the internal structure might look like this:

```typescript
// Example state structure (internal representation) - using traceId as scope
{
  "motia:state:{traceId-123}": {  // State for flow execution with traceId 'traceId-123' (scope)
    "booking": {                 // Namespaced key 'booking'
      "customer": { ... },
      "venue": { ... }
    },
    "payment": {                 // Namespaced key 'payment'
      "status": "pending",
      "amount": 100
    }
  },
  "motia:state:{traceId-456}": {  // State for another flow execution with traceId 'traceId-456' (different scope)
    // ... different state data for this flow ...
  }
}
```

> **Info:** You can access the `state` manager within any step through the `ctx` (context) argument, which is automatically injected into your [step handler](/docs/concepts/steps/defining-steps#handler). While **`traceId` from `ctx.traceId` is the recommended scope for flow isolation**, remember that **you can use any string as the scope** parameter in `state` methods for more advanced state management scenarios.

## Using State in Steps

<Tabs items={['TypeScript', 'JavaScript', 'Python']}>
  <Tab label="TypeScript">
    ```typescript
    import { Handlers } from 'motia'

    interface BookingData {
      customer: { name: string; email: string };
      venue: { id: string; name: string };
    }

    export const handler: Handlers['StepName'] = async (input, { state, traceId }) => { // Get traceId from context
      // Store state (using traceId as scope)
      await state.set<BookingData>(traceId, 'booking', {
        customer: input.customer,
        venue: input.venue,
      });

      // Retrieve state (using traceId as scope)
      const booking = await state.get<BookingData>(traceId, 'booking');

      // Delete specific state (using traceId as scope)
      await state.delete(traceId, 'booking');

      // Clear all state for this flow (using traceId as scope)
      await state.clear(traceId);
    }
    ```

  </Tab>

  <Tab label="JavaScript">
    ```javascript
    import { Handlers } from 'motia'

    export const handler: Handlers['StepName'] = async (input, { state, traceId }) => { // Get traceId from context
      // Store state (using traceId as scope)
      await state.set(traceId, 'booking', {
        customer: input.customer,
        venue: input.venue,
      });

      // Retrieve state (using traceId as scope)
      const booking = await state.get(traceId, 'booking');

      // Delete specific state (using traceId as scope)
      await state.delete(traceId, 'booking');

      // Clear all state for this flow (using traceId as scope)
      await state.clear(traceId);
    }
    ```

  </Tab>

  <Tab label="Python">
    ```python
    async def handler(input, ctx): # ctx is the context object
        trace_id = ctx.trace_id # Access traceId from context

        # Store state (using traceId as scope)
        await ctx.state.set(trace_id, 'booking', {
            'customer': input.get("customer"),
            'venue': input.get("venue")
        })

        # Retrieve state (using traceId as scope)
        booking = await ctx.state.get(trace_id, 'booking')

        # Delete specific state (using traceId as scope)
        await ctx.state.delete(trace_id, 'booking')

        # Clear all state (using traceId as scope)
        await ctx.state.clear(trace_id)
    ```
  </Tab>
</Tabs>

## Debugging

### Inspecting State

<Tabs items={['Memory', 'File', 'Redis']}>
  <Tab label="Memory">
    > State is only available during runtime in the Node.js process memory. You cannot inspect memory state directly outside of a running step execution. Use logging within your steps to output state values for debugging purposes.
  </Tab>
  <Tab label="File">
    To inspect state stored in the **File Adapter**, you can directly view the contents of the state file using the Motia CLI:

    ```bash
    # View state file contents
    motia state list
    ```

    This command will output the entire state file (motia.state.json) content in JSON format to your console, allowing you to examine the stored state data.

  </Tab>
  <Tab label="Redis">
    To inspect state stored in **Redis Adapter**, you can use the `redis-cli` command-line tool to interact with your Redis server:

    ```bash
    # List all state keys (under the motia:state prefix)
    redis-cli KEYS "motia:state:*"

    # Get specific state for a given traceId and key
    redis-cli GET "motia:state:{traceId}:booking"
    ```
    **Note:** Replace `{traceId}` in the `redis-cli GET` command with the actual `traceId` of the flow execution you are debugging. Replace `booking` with the specific `key` you want to inspect.

  </Tab>
</Tabs>

## Best Practices

### Namespacing

Use dot notation to organize related state data hierarchically:

<Tabs items={['TypeScript', 'JavaScript', 'Python']}>
  <Tab label="TypeScript">
    ```typescript
    // Good - Organized hierarchically (using traceId scope)
    await state.set(traceId, 'booking.customer', customerData)
    await state.set(traceId, 'booking.venue', venueData)
    await state.set(traceId, 'payment.status', 'pending')

    // Avoid - Flat structure (using traceId scope)
    await state.set(traceId, 'customer', customerData)
    await state.set(traceId, 'venue', venueData)
    await state.set(traceId, 'paymentStatus', 'pending')
    ```

  </Tab>

  <Tab label="JavaScript">
    ```javascript
    // Good - Organized hierarchically (using traceId scope)
    await state.set(traceId, 'booking.customer', customerData)
    await state.set(traceId, 'booking.venue', venueData)
    await state.set(traceId, 'payment.status', 'pending')

    // Avoid - Flat structure (using traceId scope)
    await state.set(traceId, 'customer', customerData)
    await state.set(traceId, 'venue', venueData)
    await state.set(traceId, 'paymentStatus', 'pending')
    ```

  </Tab>

  <Tab label="Python">
    ```python
    # Good - Organized hierarchically (using traceId scope)
    await ctx.state.set(trace_id, 'booking.customer', customer_data)
    await ctx.state.set(trace_id, 'booking.venue', venue_data)
    await ctx.state.set(trace_id, 'payment.status', 'pending')

    // Avoid - Flat structure (using traceId scope)
    await ctx.state.set(trace_id, 'customer', customer_data)
    await ctx.state.set(trace_id, 'venue', venue_data)
    await ctx.state.set(trace_id, 'payment_status', 'pending')
    ```

  </Tab>
</Tabs>

### Type Safety

Define types for your state data to ensure consistency:

<Tabs items={['TypeScript', 'JavaScript', 'Python']}>
  <Tab label="TypeScript">
    ```typescript
    interface CustomerData {
      name: string;
      email: string;
    }

    interface VenueData {
      id: string;
      capacity: number;
    }

    type BookingState = {
      customer: CustomerData;
      venue: VenueData;
      status: 'pending' | 'confirmed';
    }

    const booking = await state.get<BookingState>(traceId, 'booking')
    ```

  </Tab>

{' '}
<Tab label="JavaScript">
  ```javascript // Define types or interfaces as needed for documentation clarity (optional in JS) const booking = await
  state.get(traceId, 'booking') // No type casting in JS example ```
</Tab>

  <Tab label="Python">
    ```python
    from dataclasses import dataclass
    from typing import Literal

    @dataclass
    class CustomerData:
        name: str
        email: str

    @dataclass
    class VenueData:
        id: str
        capacity: int

    @dataclass
    class BookingState:
        customer: CustomerData
        venue: VenueData
        status: Literal['pending', 'confirmed']

    booking = await state.get(traceId, 'booking')
    ```

  </Tab>
</Tabs>

### Cleanup

Always clean up state when you're done with it:

<Tabs items={['TypeScript', 'JavaScript', 'Python']}>
    <Tab label="TypeScript">
      ```typescript
      export const handler: Handlers['StepName'] = async (input, { state, traceId }) => {
        try {
          await processBooking(input)
          // Clean up specific keys
          await state.delete(traceId, 'booking.customer')
          // Or clean everything
          await state.clear(traceId)
        } catch (error) {
          // Handle errors
        }
      }
      ```
    </Tab>

    <Tab label="JavaScript">
      ```javascript
      export const handler = async (input, { state, traceId }) => {
        try {
          await processBooking(input)
          // Clean up specific keys
          await state.delete(traceId, 'booking.customer')
          // Or clean everything
          await state.clear(traceId)
        } catch (error) {
          // Handle errors
        }
      }
      ```
    </Tab>

    <Tab label="Python">
      ```python
      async def handler(input, ctx):
          trace_id = ctx.trace_id
          try:
              await process_booking(input)
              # Clean up specific keys
              await ctx.state.delete(trace_id, 'booking.customer')
              # Or clean everything
              await ctx.state.clear(trace_id)
          except Exception as error:
              # Handle errors
              pass
      ```
    </Tab>
</Tabs>

### Performance Considerations

| Consideration    | Description                                                          |
| ---------------- | -------------------------------------------------------------------- |
| Batch Operations | Group related state updates and use atomic operations when possible  |
| State Size       | Keep state data minimal and consider access patterns                 |
| TTL Management   | Set appropriate TTLs based on flow duration and error recovery needs |

### Custom State Adapters

```typescript title="Custom State Adapter Example"
import { StateAdapter } from 'motia'

class CustomStateAdapter extends StateAdapter {
  async get<T>(traceId: string, key: string): Promise<T | null> {
    // Implementation
    return null
  }

  async set<T>(traceId: string, key: string, value: T): Promise<void> {
    // Implementation
  }

  async delete(traceId: string, key: string): Promise<void> {
    // Implementation
  }

  async clear(traceId: string): Promise<void> {
    // Implementation
  }

  async cleanup(): Promise<void> {
    // Implementation
  }
}
```

### Storage Adapters

Motia.dev offers three built-in storage adapters:

- 📁 **File (Default):** Persists state to a JSON file in your project (`.motia/motia.state.json`). No configuration needed for basic use.
- 💾 **Memory:** Stores state in-memory. Fastest option, but state is not persistent across server restarts. Useful for development and non-critical data.
- ⚡ **Redis:** Leverages Redis for persistent and scalable state storage. Ideal for production environments and flows requiring high availability and data durability.

To configure a different state adapter, modify the `config.yml` file in your project root:

```
my-project/
├── config.yml
└── steps/
    ├── step-1.ts
    └── step-2.ts
```

**File Adapter (Default)**

> Default, no configuration required, state is stored into .motia/motia.state.json in your project root

**Memory Adapter**

```yaml title="config.yml"
state:
  adapter: memory
```

> **Warning: Memory Adapter**
> State is stored in-memory and will be lost when the Motia.dev server restarts. Suitable for development and testing.

**Redis Adapter**

```yaml title="config.yml"
state:
  adapter: redis
  host: localhost # Redis server host (e.g., 'localhost' or IP address)
  port: 6379 # Redis server port (default: 6379)
  password: optional # Redis password (if required)
  ttl: 3600 # Optional: State Time-To-Live in seconds (e.g., 3600 seconds = 1 hour)
```

> **Info: Redis Adapter**
> Recommended for production environments. Requires a running Redis server. The `ttl` (Time-To-Live) option is available to automatically expire state data after a specified number of seconds, helping to manage Redis storage.

### Common Issues

| Issue             | Troubleshooting Steps                                                                                                                                                                            |
| ----------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
| State Not Found   | - Verify state adapter configuration\n- Check TTL expiration (Redis)\n- Ensure file permissions (File adapter)\n- **Ensure correct `traceId` is being used in `state.get(traceId, key)` calls.** |
| Persistence       | - Memory adapter: State is lost on process restart\n- File adapter: Check file write permissions\n- Redis: Verify connection and persistence settings                                            |
| Concurrent Access | - Memory/File: Limited concurrent flow support\n- Redis: Use atomic operations and implement retry logic                                                                                         |


-   [API Step](/llm-docs/concepts/steps/api.md): Documentation for API Step.
---
title: API Step
---

An **API step** is exposed as an HTTP endpoint that acts as an entry point into your sequence of steps, or **flow**. It allows external systems or clients to trigger and interact with your flows through a REST API interface. Like any Motia Step, an API Step can be configured to emit events or wait for events to occur.

## Config

The following properties are specific to the API Step, in addition to the [common step config](/docs/concepts/steps/defining-steps#config).

<DescriptionTable
  type={{
    path: {
      description: 'The HTTP path for the API endpoint',
      type: 'string',
    },
    method: {
      description: 'The HTTP method for the API endpoint (GET, POST, PUT, DELETE, etc.)',
      type: 'string',
    },
    bodySchema: {
      description:
        'Schema for validating the request body. For TypeScript/JavaScript steps, it uses zod schemas. For Python steps, it uses Pydantic models.',
      type: 'object',
    },
    responseSchema: {
      description:
        'Mostly used for documentation, the expected output of an API endpoint. For TypeScript/JavaScript steps, it uses zod schemas. For Python steps, it uses Pydantic models or Dict Json Schema.',
      type: 'object',
    },
    queryParams: {
      description: 'Mostly for documentation, the expected query params',
      type: 'array',
    },
    middleware: {
      description: 'Optional middleware functions to run before the handler',
      type: 'array',
    },
  }}
/>

## Defining an API Step

<Tabs items={['TypeScript', 'JavaScript', 'Python']}>
  <Tab value="TypeScript">
    ```typescript
    import { ApiRouteConfig, Handlers } from 'motia'
    import { z } from 'zod'

    export const config: ApiRouteConfig = {
      type: 'api',
      name: 'GetMessage',
      description: 'Retrieves a generated message from OpenAI based on the Trace ID returned by the POST /openai endpoint',
      path: '/openai/:traceId',
      method: 'GET',
      emits: ['call-openai'],
      flows: ['openai'],
      responseSchema: {
        // When response code is 200
        200: z.object({ message: z.string({ description: 'The message from OpenAI' }) }),
        // When response code is 400
        400: z.object({ message: z.string({ description: 'The error message' }) })
      },
      queryParams: [
        {
          name: 'includeProps',
          description: 'Whether to include the properties of the message',
        },
      ],
    }

    export const handler: Handlers['GetMessage'] = async (req, { logger }) => {
      logger.info('[Call OpenAI] Received callOpenAi event', req)

      return {
        status: 200,
        body: { message: 'OpenAI response sent' },
      }
    }
    ```

  </Tab>
  <Tab value="JavaScript">
    ```typescript
    const { z } = require('zod')

    export const config = {
      type: 'api',
      name: 'Get Message by Trace ID',
      description: 'Retrieves a generated message from OpenAI based on the Trace ID returned by the POST /openai endpoint',
      path: '/openai/:traceId',
      method: 'GET',
      emits: ['call-openai'],
      flows: ['openai'],
      responseSchema: {
        // When response code is 200
        200: z.object({ message: z.string({ description: 'The message from OpenAI' }) }),
        // When response code is 400
        400: z.object({ message: z.string({ description: 'The error message' }) })
      },
      queryParams: [
        {
          name: 'includeProps',
          description: 'Whether to include the properties of the message',
        },
      ],
    }

    export const handler = async (req, { logger }) => {
      logger.info('[Call OpenAI] Received callOpenAi event', req)

      return {
        status: 200,
        body: { message: 'OpenAI response sent' },
      }
    }
    ```

  </Tab>
  <Tab value="Python">
    ```python
    from pydantic import BaseModel
    
    # Define a Pydantic model for request body validation
    class RequestBody(BaseModel):
        message: str

    config = {
      "type": "api",
      "name": "Get Message by Trace ID",
      "description": "Retrieves a generated message from OpenAI based on the Trace ID returned by the POST /openai endpoint",
      "path": "/openai/:traceId",
      "method": "GET",
      "emits": ["call-openai"],
      "flows": ["openai"],
      "responseSchema": {
        "200": RequestBody.model_json_schema()
      },
      "queryParams": [
        {
          "name": "includeProps",
          "description": "Whether to include the properties of the message",
        },
      ],
    }

    async def handler(req, context):
      context.logger.info("[Call OpenAI] Received callOpenAi event", {"body": req.get("body")})

      return {
        "status": 200,
        "body": { "message": "OpenAI response sent" },
      }
    ```

  </Tab>
</Tabs>

This should create an endpoint that can be viewed and requested from Workbench UI.

![Endpoint Visualization in Workbench](../../img/endpoints.png)

The following examples showcase how to configure an **API Step**

## Using Middleware

API Steps support middleware functions that can be applied to requests before they reach your handler. Middleware functions are completely framework-agnostic and can perform tasks such as:

- Authentication and authorization
- Request logging
- Rate limiting
- CORS handling
- Request validation
- Response transformation

### Middleware Function Signature

```typescript
type ApiMiddleware = (req: ApiRequest, ctx: FlowContext, next: () => Promise<ApiResponse>) => Promise<ApiResponse>
```

Middleware functions receive:

- `req`: The API request object with body, headers, pathParams, and queryParams
- `ctx`: The flow context with logger, state, emit, and traceId
- `next`: A function to call the next middleware or handler in the chain
  - Call `next()` to continue to the next middleware or handler
  - The return value of `next()` is the response from the next middleware or handler
  - You can modify this response before returning it

### Example Middleware Usage

```typescript
import { ApiMiddleware } from 'motia'

// Logging middleware
const loggingMiddleware: ApiMiddleware = async (req, ctx, next) => {
  ctx.logger.info('Request received', { path: req.pathParams })
  const start = Date.now()

  // Call the next middleware and get its response
  const response = await next()

  const duration = Date.now() - start
  ctx.logger.info('Request completed', { duration, status: response.status })

  return response
}

// Authentication middleware
const authMiddleware: ApiMiddleware = async (req, ctx, next) => {
  const authHeader = req.headers.authorization

  if (!authHeader) {
    // Return early without calling next()
    return {
      status: 401,
      body: { error: 'Unauthorized' },
    }
  }

  // Continue to the next middleware
  return next()
}

export const config = {
  type: 'api',
  name: 'protected-endpoint',
  path: '/api/protected',
  method: 'POST',
  emits: ['USER_ACTION'],
  middleware: [loggingMiddleware, authMiddleware],
}

export const handler = async (req, ctx) => {
  // This handler will only be called if all middleware pass
  return {
    status: 200,
    body: { message: 'Protected data accessed successfully' },
  }
}
```

### Creating Custom Middleware

You can create your own middleware functions:

```typescript
import { ApiMiddleware } from 'motia'

// Request modification middleware
const requestModifierMiddleware: ApiMiddleware = async (req, ctx, next) => {
  // Modify the request before passing it to the next middleware
  req.headers['x-modified-by'] = 'middleware'
  req.body.timestamp = Date.now()

  // Call the next middleware in the chain
  return next()
}

// Response modification middleware
const responseModifierMiddleware: ApiMiddleware = async (req, ctx, next) => {
  // Call the next middleware in the chain
  const response = await next()

  // Modify the response before returning it
  response.headers = {
    ...response.headers,
    'x-powered-by': 'Motia',
  }

  return response
}

// Error handling middleware
const errorHandlingMiddleware: ApiMiddleware = async (req, ctx, next) => {
  try {
    // Call the next middleware in the chain
    return await next()
  } catch (error) {
    ctx.logger.error('Error in handler', { error })
    return {
      status: 500,
      body: { error: 'Internal server error' },
    }
  }
}

// Rate limiter middleware with state
const rateLimiterMiddleware: ApiMiddleware = (() => {
  // Closure to maintain state between requests
  const requests: Record<string, number[]> = {}
  const limit = 100
  const windowMs = 60000 // 1 minute

  return async (req, ctx, next) => {
    const ip = req.headers['x-forwarded-for'] || 'unknown-ip'
    const ipStr = Array.isArray(ip) ? ip[0] : ip

    const now = Date.now()
    if (!requests[ipStr]) {
      requests[ipStr] = []
    }

    // Remove old requests outside the time window
    requests[ipStr] = requests[ipStr].filter((time) => now - time < windowMs)

    if (requests[ipStr].length >= limit) {
      return {
        status: 429,
        body: { error: 'Too many requests, please try again later' },
      }
    }

    // Add current request
    requests[ipStr].push(now)

    return next()
  }
})()
```

<Tabs items={['TypeScript', 'JavaScript', 'Python']}>
  <Tab value="TypeScript">
    ```typescript
      import { ApiRouteConfig, Handlers } from 'motia'
      import { z } from 'zod'

      export const config: ApiRouteConfig = {
        type: 'api',
        name: 'TestStateApiTrigger',
        description: 'test state',
        path: '/test-state',
        method: 'POST',
        emits: ['test-state'],
        bodySchema: z.object({}),
        flows: ['test-state'],
      }

      export const handler: Handlers['TestStateApiTrigger'] = async (req, { logger, emit }) => {
        logger.info('[Test State] Received request', req)

        await emit({
          topic: 'test-state',
          data: req.body
        })

        return {
          status: 200,
          body: { message: 'Success' },
        }
      }
    ```

  </Tab>
  <Tab value="JavaScript">
    ```javascript
    const { z } = require('zod')

    exports.config = {
      type: 'api',
      name: 'Test state api trigger',
      description: 'test state',
      path: '/test-state',
      method: 'POST',
      emits: ['test-state'],
      bodySchema: z.object({}),
      flows: ['test-state'],
    }

    exports.handler = async (req, { logger, emit }) => {
      logger.info('[Test State] Received request', req)

      await emit({
        topic: 'test-state',
        data: req.body
      })

      return {
        status: 200,
        body: { message: 'Success' },
      }
    }
    ```

  </Tab>

  <Tab value="Python">
    ```python
    from typing import Any, Dict, Callable
    from motia import ApiMiddleware
    from datetime import datetime
    import time

    from pydantic import BaseModel

    # Define a Pydantic model for request body validation
    class RequestBody(BaseModel):
        message: str

    # Request modification middleware
    async def request_modifier_middleware(data: Dict[str, Any], ctx: Any, next_fn: Callable):
        # Modify the request before passing it to the next middleware
        data['headers']['x-modified-by'] = 'middleware'
        data['body']['timestamp'] = int(time.time() * 1000)

        # Call the next middleware in the chain
        return await next_fn()

    # Response modification middleware
    async def response_modifier_middleware(data: Dict[str, Any], ctx: Any, next_fn: Callable):
        # Call the next middleware in the chain
        response = await next_fn()

        # Modify the response before returning it
        response['headers'] = {
            **response.get('headers', {}),
            'x-powered-by': 'Motia'
        }

        return response

    # Error handling middleware
    async def error_handling_middleware(data: Dict[str, Any], ctx: Any, next_fn: Callable):
        try:
            # Call the next middleware in the chain
            return await next_fn()
        except Exception as error:
            ctx.logger.error('Error in handler', {'error': str(error)})
            return {
                'status': 500,
                'body': {'error': 'Internal server error'}
            }

    # Rate limiter middleware with state using a closure
    def create_rate_limiter_middleware():
        # Closure to maintain state between requests
        requests: Dict[str, list] = {}
        limit = 100
        window_ms = 60000  # 1 minute

        async def rate_limiter_middleware(data: Dict[str, Any], ctx: Any, next_fn: Callable):
            ip = data['headers'].get('x-forwarded-for', ['unknown-ip'])
            ip_str = ip[0] if isinstance(ip, list) else ip

            now = int(time.time() * 1000)
            if ip_str not in requests:
                requests[ip_str] = []

            # Remove old requests outside the time window
            requests[ip_str] = [t for t in requests[ip_str] if now - t < window_ms]

            if len(requests[ip_str]) >= limit:
                return {
                    'status': 429,
                    'body': {'error': 'Too many requests, please try again later'}
                }

            # Add current request
            requests[ip_str].append(now)

            return await next_fn()

        return rate_limiter_middleware

    config = {
        'type': 'api',
        'name': 'Test state api trigger',
        'description': 'test state',
        'path': '/test-state',
        'method': 'POST',
        'emits': ['test-state'],
        'flows': ['test-state'],
        'bodySchema': RequestBody.model_json_schema(), # We use jsonschema to validate
        'middleware': [
            request_modifier_middleware,
            response_modifier_middleware,
            error_handling_middleware,
            create_rate_limiter_middleware()
        ]
    }

    async def handler(req, context):
        context.logger.info('[Test State] Received request', {'body': req.get("body")})

        await context.emit({
            'topic': 'test-state',
            'data': req.body
        })

        return {
            'status': 200,
            'body': {'message': 'Success'}
        }
    ```

  </Tab>
</Tabs>


-   [Cron Step](/llm-docs/concepts/steps/cron.md): Documentation for Cron Step.
---
title: Cron Step
---

The **Cron Step** allows you to schedule your steps to run at specified intervals. It is a powerful tool for automating your business logic.

## Config

The following properties are specific to the Cron Step, in addition to the [common step config](/docs/concepts/steps/defining-steps#config).

<DescriptionTable
  type={{
    cron: {
      description: 'The cron schedule expression for your step',
      type: 'string',
    },
  }}
/>

The following examples showcase how to configure an **CRON Step**

<Tabs  items={['TS', 'JS', 'Python']}>
  <Tab value="TS">
    ```typescript
    import { CronConfig, Handlers } from 'motia'

    export const config: CronConfig = {
      type: 'cron' as const,
      name: 'PeriodicJob',
      description: 'Runs every minute and emits a timestamp',
      cron: '0 * * * *', // run every hour at minute 0
      emits: ['cron-ticked'],
      flows: ['cron-example'],
    }

    export const handler: Handlers['PeriodicJob'] = async ({ emit }) => {
      await emit({
        topic: 'cron-ticked',
        data: { message: 'Cron job executed' },
      })
    }
    ```

  </Tab>
  <Tab value="JS">
    ```javascript
    const config = {
      type: 'cron',
      name: 'PeriodicJob',
      description: 'Runs every minute and emits a timestamp',
      cron: '0 * * * *', // run every hour at minute 0
      emits: ['cron-ticked'],
      flows: ['cron-example'],
    };

    const handler = async ({ emit }) => {
      await emit({
        topic: 'cron-ticked',
        data: { message: 'Cron job executed' },
      })
    }

    ```

  </Tab>
  <Tab value="Python">
    ```python
    config = {
        "type": "cron",
        "name": "PeriodicJob",
        "description": "Runs every minute and emits a timestamp",
        "cron": "0 * * * *",
        "emits": ["cron-ticked"],
        "flows": ["cron-example"]
    }
  
    async def handler(context):
        await context.emit({
            "topic": "cron-ticked",
            "data": { "message": "Cron job executed" },
        })

    ```
  </Tab>
</Tabs>


-   [Defining Steps](/llm-docs/concepts/steps/defining-steps.md): Documentation for Defining Steps.
---
title: Defining Steps
---

Steps are the fundamental building blocks in Motia that encapsulate isolated pieces of business logic. 

Steps have two core behaviors:

1. **Event Subscription**: Steps can subscribe to specific topics, allowing them to listen and react to particular events.
2. **Event Emission**: Steps can emit new topics, triggering an event for other steps to react to.

Steps can operate in two different patterns:
- **Independent**: Each step can function as a standalone unit, processing its logic in isolation.
- **Flow**: Steps can be connected together in a sequence, creating a **flow** where the output of one step becomes the input for another.

This modular approach allows you to:
- Build reusable components of business logic
- Create complex workflows by combining simple steps
- Maintain clear separation of concerns
- Scale and modify parts of your system independently

Steps can be defined in any language that Motia supports, such as TypeScript, JavaScript, and Python. Steps can be of type [`event`](/docs/concepts/steps/event), [`api`](/docs/concepts/steps/api), or [`cron`](/docs/concepts/steps/cron). Steps are composed of a `config` object and a `handler` function.

## Config

A step's configuration is defined through a `config` object that must be exported. This object contains essential properties that tell Motia how to interact with the step.

<DescriptionTable
  type={{
    type: {
      description: 'The step type: event, api, or cron',
      type: 'string',
    },
    name: {
      description: 'A unique identifier for the step, used in Motia Workbench visualization tool',
      type: 'string',
    },
    subscribes: {
      description: 'A list of topics this step listens to',
      type: 'string[]',
      default: []
    },
    emits: {
      description: 'A list of topics this step can emit',
      type: 'string[]',
    },
    flows: {
      description: 'A list of flow identifiers that this step belongs to',
      type: 'string[]',
    },
    description: {
      description: 'Optional description for documentation and visualization',
      type: 'string',
    }
  }}
/>

Each step type has its own set of properties, specific to that step type, which are described in the following sections.

<Breadcrumb items={[{
  name: 'Event Steps',
  url: '/docs/concepts/steps/event'
}, {
  name: 'API Steps',
  url: '/docs/concepts/steps/api'
}, {
  name: 'Cron Steps',
  url: '/docs/concepts/steps/cron'
}]} />

## Handler

A handler holds the business logic of a step. When an event occurs that matches the step's subscribed topics, the handler automatically runs with two key pieces of information:

1. The input data from the triggering event
2. A context object that provides useful tools:
   - `emit`: Sends new events to other steps
   - `traceId`: Helps track the flow of operations
   - `state`: Manages data persistence
   - `logger`: Records important information

Here're examples of how to define a handler in the Motia supported languages:

<Tabs items={['TS', 'JS', 'Python']}>
  <Tab value="TS">
    ```typescript
    import { EventConfig, Handlers } from 'motia'

    export const config: EventConfig = {
      type: 'event',
      name: 'MinimalStep',
      subscribes: ['start'],
      emits: ['done'],
    }

    export const handler: Handlers['MinimalStep'] = async (input, { emit, traceId, state, logger }) => {
      await emit({ topic: 'done', data: {} })
    }
    ```
  </Tab>
  <Tab value="JS">
    ```javascript
    exports.config = {
      type: 'event',
      name: 'Minimal Step',
      subscribes: ['start'],
      emits: ['done'],
    }

    exports.handler = async (input, { emit, traceId, state, logger }) => {
      await emit({ topic: 'done', data: {} })
    }
    ```
  </Tab>
  <Tab value="Python">
    ```python
    config = {
        'type': 'event',
        'name': 'Minimal Step',
        'subscribes': ['start'],
        'emits': ['done'],
    }

    async def handler(args, ctx):
      await ctx.emit({'topic': 'done', 'data': {}})
    ```
  </Tab>
</Tabs>

<Callout>
Follow the **[quick start](/docs/getting-started/quick-start)** guide if you haven't set up Motia yet.
</Callout>


-   [Event Step](/llm-docs/concepts/steps/event.md): Documentation for Event Step.
---
title: Event Step
---

The **Event Step** lets you define custom logic in response to subscribed events and at the same time trigger other steps by emitting new events. It enables communication between different parts of your flow.

## Config

The following properties are specific to the Event Step, in addition to the [common step config](/docs/concepts/steps/defining-steps#config).

<DescriptionTable
  type={{
    input: {
      description:
        'This is used for input validation. For TypeScript/JavaScript steps, it uses zod schemas. For Python steps, it uses Pydantic models. This validates the input before executing the step handler.',
      type: 'string[]',
    },
  }}
/>

The following examples showcase how to configure an **Event Step**

<Tabs  items={['TS', 'JS', 'Python']}>
  <Tab value="TS">
    ```typescript
    import { EventConfig, Handlers } from 'motia'
    import { z } from 'zod'

    export const config: EventConfig = {
      type: 'event',
      name: 'stepA',
      description: 'Hello from Step A',
      subscribes: ['pms.start'],
      emits: ['pms.stepA.done'],
      input: z.object({ message: z.string() }),
      flows: ['parallel-merge'],
    }

    export const handler: Handlers['stepA'] = async (input, { emit, logger }) => {
      logger.info('Processing message:', input.message)

      await emit({
        topic: 'pms.stepA.done',
        data: {
          result: `Processed: ${input.message}`
        }
      })
    }
    ```
  </Tab>
  <Tab value="JS">
    ```javascript
    const z = require('zod');

    const config = {
      type: 'event',
      name: 'stepA',
      description: 'Hello from Step A',
      subscribes: ['pms.start'],
      emits: ['pms.stepA.done'],
      input: z.object({ message: z.string() });,
      flows: ['parallel-merge'],
    };

    const handler = async (input, { emit, logger }) => {
      logger.info('Processing message:', input.message)

      await emit({
        topic: 'pms.stepA.done',
        data: {
          result: `Processed: ${input.message}`
        }
      })
    };

    module.exports = { config, handler };
    ```
  </Tab>
  <Tab value="Python">
    ```python
    config = {
      "type": "event",
      "name": "Call OpenAI",
      "subscribes": ["call-openai"], 
      "emits": ["openai-response"],
      "input": {
        "type": "object",
        "properties": { "type": "string" },
      },
      "flows": ["openai"]
    }

    async def handler(input, context):
      context.logger.info("Processing input:", { "input": input })

      await context.emit({
        "topic": "openai-response",
        "data": {
          "result": f"Processed: {input.get("message", "")}"
        }
      })
    ```
  </Tab>
</Tabs>

## Example


-   [streams](/llm-docs/concepts/streams.md): Documentation for streams.
---
title: Streams 
description: Motia Streams are a way to quickly push updates from your asynchronous workflows to the client without having to implement any sort of polling processes.
---

## How it works

You first need to define a stream in your project

### Defining a stream

To be able to use Motia Sockets, you need to define a stream

Create a file called `open-ai.stream.ts` under `steps/` folder

```typescript
import { StreamConfig } from 'motia'
import { z } from 'zod'

export const config: StreamConfig = {
  /**
   * This will be converted in the property on the FlowContext:
   * 
   * context.streams.openai
   */
  name: 'openai',
  /**
   * Schema is important to define the type of the stream, the API
   * generated to interact with this stream will have the structure defined here
   */  
  schema: z.object({ message: z.string() }),

  /**
   * Base config is used to configure the stream
   */
  baseConfig: {
    /**
     * There are two storage types: default and custom
     * Default will use the default storage to store the data.
     * 
     * Custom will use a custom storage, you need to implement 
     * the StateStream class.
     */
    storageType: 'default',
  },
}
```

Once a stream is created, it should be immediately available in FlowContext (make sure to have motia running on the project)

Then you can simply create records using the streams API in your step

```typescript
import { ApiRouteConfig, Handlers } from 'motia'
import { z } from 'zod'

export const config: ApiRouteConfig = {
  type: 'api',
  name: 'OpenAiApi',
  description: 'Call OpenAI',
  path: '/open-ai',
  method: 'POST',
  emits: ['openai-prompt'],
  flows: ['open-ai'],
  bodySchema: z.object({ message: z.string({ description: 'The message to send to OpenAI' }) }),
  responseSchema: {
    200: z.object({ message: z.string({ description: 'The message from OpenAI' }) }) 
  },
}

export const handler: Handlers['OpenAiApi'] = async (req, { traceId, logger, emit, streams }) => {
  logger.info('[Call OpenAI] Received callOpenAi event', { message: req.body.message })

  /**
   * This creates a record with empty message string to be populated in the next step
   */
  const result = await streams.openai.set(traceId, 'message', { message: '' })

  await emit({
    topic: 'openai-prompt',
    data: { message: req.body.message },
  })

  return { status: 200, body: result }
}
```

The previous step just prepares a message to be created by Open AI via OpenAI SDK stream, which will be populated in the next step

```typescript
import { EventConfig, Handlers } from 'motia'
import { OpenAI } from 'openai'
import { z } from 'zod'

export const config: EventConfig = {
  type: 'event',
  name: 'CallOpenAi',
  description: 'Call OpenAI',
  subscribes: ['openai-prompt'],
  emits: [],
  input: z.object({
    message: z.string({ description: 'The message to send to OpenAI' }),
  }),
  flows: ['open-ai'],
}

export const handler: Handlers['CallOpenAi'] = async (input, context) => {
  const { logger, traceId } = context
  const openai = new OpenAI({ apiKey: process.env.OPENAI_API_KEY })

  logger.info('[Call OpenAI] Received callOpenAi event', input)

  const result = await openai.chat.completions.create({
    messages: [{ role: 'system', content: input.message }],
    model: 'gpt-4o-mini',
    stream: true,
  })

  const messages: string[] = []

  for await (const chunk of result) {
    messages.push(chunk.choices[0].delta.content ?? '')

    /**
     * Now we're populating a previously created message with the streamed data from OpenAI
     */
    await context.streams.openai.set(traceId, 'message', { 
      message: messages.join(''),
    })
  }

  logger.info('[Call OpenAI] OpenAI response', result)
}
```

## Testing Streams in Workbench

We know testing real time events is not easy as a backend developer, so we've added a way to test streams in the Workbench.

Here are the steps to test streams in the Workbench:

1. The API Step that provides a stream item should return the object

```typescript
export const handler: Handlers['OpenAiApi'] = async (req, { traceId, logger, emit, streams }) => {
  logger.info('[Call OpenAI] Received callOpenAi event', { message: req.body.message })

  /**
   * This creates a record with empty message string to be populated in the next step
   */
  const result = await streams.openai.set(traceId, 'message', { message: '' })

  await emit({
    topic: 'openai-prompt',
    data: { message: req.body.message },
  })

  /**
   * Return the entire object received from the create method
   */
  return { status: 200, body: result }
}
```

2. Navigate to [http://localhost:3000/endpoints](http://localhost:3000/endpoints) in your Workbench
3. Open up your endpoint and click on the `Test` button
4. The result will automatically be streamed from the server to the client streaming it's state real-time.

![Stream Test in Workbench](./../img/streams-test-workbench.gif)


## Consuming stream on the browser

```
npm install @motiadev/stream-client-react
```

Then add the provider to the root of your project

```tsx
<MotiaStreamProvider address="ws://localhost:3000">
  ...
</MotiaStreamProvider>
```

then on your component or hook, just use

```typescript
const messageId = '' // get the id back from the API call

// data below will be updated whenever it's updated in the server
const { data } = useStreamItem({ 
  streamName: 'openai',
  groupId: messageId,
  id: 'message'
})
```

-   [testing](/llm-docs/concepts/testing.md): Documentation for testing.
---
title: Testing
description: Learn how to write and run tests for your Motia components
---

# Testing

Testing is an essential part of building reliable and maintainable Motia applications. Motia provides built-in support for writing and running tests to ensure the correctness of your steps, flows, and event handling logic.

## Writing Tests for Motia Components

Motia uses [Jest](https://jestjs.io/) as its testing framework. You can write tests for your Motia components using Jest's syntax and assertions.

### Step Tests

To test a step, create a test file with the same name as the step file, but with a `.test.ts` or `.test.js` extension. For example, if your step file is named `my-step.step.ts`, create a test file named `my-step.step.test.ts`.

Here's an example of a step test:

```typescript
// my-step.step.test.ts
import { createTestContext } from '@motiadev/testing'
import { handler } from './my-step.step'

describe('MyStep', () => {
  it('should emit an event with the correct data', async () => {
    const { emit, done } = createTestContext()

    await handler({ name: 'John' }, { emit })

    expect(emit).toHaveBeenCalledWith({
      type: 'my-event',
      data: { greeting: 'Hello, John!' },
    })

    done()
  })
})
```

In this example, we use the `createTestContext` function from `@motiadev/testing` to create a test context with mocked `emit` and `done` functions. We then call the step's `handler` function with test input and the mocked context. Finally, we assert that the `emit` function was called with the expected event type and data.

### Flow Tests

To test a flow, create a test file with the flow name and a `.test.ts` or `.test.js` extension. For example, if your flow is named `my-flow`, create a test file named `my-flow.test.ts`.

Here's an example of a flow test:

```typescript
// my-flow.test.ts
import { createTestFlow } from '@motiadev/testing'
import { handler as stepAHandler } from './step-a.step'
import { handler as stepBHandler } from './step-b.step'

describe('MyFlow', () => {
  it('should execute steps in the correct order', async () => {
    const flow = createTestFlow('my-flow')
      .step('step-a', stepAHandler)
      .step('step-b', stepBHandler)

    const result = await flow.execute({ name: 'Alice' })

    expect(result).toEqual({
      greeting: 'Hello, Alice!',
      message: 'Welcome to Motia!',
    })
  })
})
```

In this example, we use the `createTestFlow` function from `@motiadev/testing` to create a test flow with the specified steps. We then execute the flow with test input and assert that the final result matches the expected output.

## Running Tests Locally

To run tests locally, use the following command:

```bash
pnpm test
```

This command will run all the test files in your project and display the test results in the terminal.

You can also run tests in watch mode, which automatically re-runs the tests whenever you make changes to your code:

```bash
pnpm test --watch
```

## Best Practices

- Write tests for each step and flow to ensure comprehensive coverage.
- Use meaningful test case descriptions to clarify the purpose of each test.
- Test edge cases and error scenarios to ensure your components handle them gracefully.
- Keep your tests focused and independent to make them easier to maintain.
- Use mocks and stubs to isolate dependencies and improve test reliability.

By following these best practices and regularly running tests, you can catch bugs early, maintain code quality, and ensure the reliability of your Motia application. 

-   [how-to-contribute](/llm-docs/contribution/how-to-contribute.md): Documentation for how-to-contribute.
---
title: How to Contribute
description: Guide for developers who want to contribute to Motia
---

# How to Contribute

Thank you for your interest in contributing to Motia! We welcome contributions from the community to help make Motia better. Here are some ways you can contribute:

## Reporting Issues

If you encounter any bugs, have feature requests, or want to discuss improvements, please [open an issue](https://github.com/MotiaDev/motia/issues) on our GitHub repository. When reporting bugs, please provide detailed information about your environment and steps to reproduce the issue.

## Submitting Pull Requests

We appreciate pull requests for bug fixes, enhancements, or new features. To submit a pull request:

1. Fork the [Motia repository](https://github.com/MotiaDev/motia) on GitHub.
2. Create a new branch from the `main` branch for your changes.
3. Make your modifications and ensure that the code follows our coding conventions.
4. Write tests to cover your changes, if applicable.
5. Commit your changes and push them to your forked repository.
6. Open a pull request against the `main` branch of the Motia repository.

Please provide a clear description of your changes in the pull request, along with any relevant information or context.

## Documentation Improvements

Improving the documentation is a great way to contribute to Motia. If you find any errors, typos, or areas that need clarification, please submit a pull request with the necessary changes. The documentation source files are located in the `packages/docs/content` directory.

## Sharing Examples and Use Cases

If you have built something interesting with Motia or have a real-world use case to share, we would love to showcase it in our [Examples](/docs/examples) section. You can contribute your examples by submitting a pull request to the [Motia Examples repository](https://github.com/MotiaDev/motia-examples).

## Spreading the Word

Help spread the word about Motia by sharing it with your friends, colleagues, and the developer community. You can also star our [GitHub repository](https://github.com/MotiaDev/motia), follow us on [Twitter](https://twitter.com/motiadev), and join our [Discord community](https://discord.gg/nJFfsH5d6v) to stay updated with the latest news and engage with other Motia developers.

We appreciate all forms of contributions and look forward to collaborating with you to make Motia even better! 

-   [Examples](/llm-docs/examples/index.md): Documentation for Examples.
---
title: Examples
---

We have curated a few examples to help you get started with Motia.

<Cards>
  <Card
    title="Sentiment Analysis"
    href="/docs/examples/sentiment-analysis"
    description="Sometimes you don't just want a simple “prompt => response.” Instead, you want the LLM to decide how to proceed A real-world example of a sentiment analysis flow"
  />
</Cards>

<br/>

## Contribute

We welcome contributions to the examples. Please submit a PR to the [examples repository](https://github.com/motiadev/motia-examples).



## Examples
[Examples](/llm-docs/examples/index.md): Code example
---
title: Examples
---

We have curated a few examples to help you get started with Motia.

<Cards>
  <Card
    title="Sentiment Analysis"
    href="/docs/examples/sentiment-analysis"
    description="Sometimes you don't just want a simple “prompt => response.” Instead, you want the LLM to decide how to proceed A real-world example of a sentiment analysis flow"
  />
</Cards>

<br/>

## Contribute

We welcome contributions to the examples. Please submit a PR to the [examples repository](https://github.com/motiadev/motia-examples).


-   [Dynamic Sentiment Analysis](/llm-docs/examples/sentiment-analysis.md): Documentation for Dynamic Sentiment Analysis.
---
title: Dynamic Sentiment Analysis
---

Sometimes you don't just want a **simple** "prompt => response." Instead, you want the LLM to decide how to proceed. Below is a minimal example that:

1. Receives user input via `POST /api/analyze-sentiment`
2. Calls OpenAI and **instructs** the LLM to return JSON with a `sentiment` field
3. Parses that JSON and **emits** different events depending on whether `sentiment` is `"positive"` or `"negative"` (or anything else)
4. Two specialized responders handle each sentiment separately

---

## The Steps

<Folder name="steps" defaultOpen>
  <File name="analyzeSentimentApi.step.ts" />
  <File name="openAiAnalyzeSentiment.step.ts" />
  <File name="handlePositive.step.ts" />
  <File name="handleNegative.step.ts" />
</Folder>

<Tabs items={['analyzeSentimentApi', 'openAiAnalyzeSentiment', 'handlePositive', 'handleNegative']}>
  <Tab value="analyzeSentimentApi">
    ```ts
    // Receives user text, emits "openai.analyzeSentimentRequest".
    import { ApiRouteConfig, StepHandler } from 'motia'
    import { z } from 'zod'

    export const config: ApiRouteConfig = {
      type: 'api',
      name: 'Analyze Sentiment (API)',
      path: '/api/analyze-sentiment',
      method: 'POST',
      emits: ['openai.analyzeSentimentRequest'],
      bodySchema: z.object({
        text: z.string().min(1, 'text is required'),
      }),
      flows: ['sentiment-demo'],
    }

    export const handler: StepHandler<typeof config> = async (req, { emit, logger }) => {
      const { text } = req.body

      logger.info('[AnalyzeSentimentAPI] Received text', { text })

      // Emit an event to call OpenAI
      await emit({
        topic: 'openai.analyzeSentimentRequest',
        data: { text },
      })

      // Return right away
      return {
        status: 200,
        body: { status: 'Accepted', message: 'Your text is being analyzed' },
      }
    }
    ```

  </Tab>
  <Tab value="openAiAnalyzeSentiment">
    ```ts
    // Calls OpenAI, instructing it to ONLY return JSON like {"sentiment":"positive","analysis":"..."}
    import { EventConfig, StepHandler } from 'motia'
    import { z } from 'zod'
    import { OpenAI } from 'openai'

    // 1) Create an OpenAI client (newer syntax)
    const openai = new OpenAI({ apiKey: process.env.OPENAI_API_KEY })

    export const config: EventConfig = {
      type: 'event',
      name: 'OpenAI Sentiment Analyzer',
      subscribes: ['openai.analyzeSentimentRequest'],
      // We'll emit different events: "openai.positiveSentiment" or "openai.negativeSentiment"
      emits: ['openai.positiveSentiment', 'openai.negativeSentiment'],
      input: z.object({ text: z.string() }),
      flows: ['sentiment-demo'],
    }

    // 3) Provide the code that runs on each event
    export const handler: StepHandler<typeof config> = async (input, { emit, logger }) => {
      logger.info('[OpenAI Sentiment Analyzer] Prompting OpenAI...', { text: input.text })

      try {
        // We'll ask the model to ONLY return JSON with a "sentiment" field
        const systemPrompt =
          'You are an assistant that returns only JSON: {"sentiment":"positive|negative","analysis":"..."}'
        const userPrompt = `Analyze the sentiment of this text: "${input.text}". Return JSON with keys "sentiment" and "analysis".`

        // 4) Use the new openai syntax:
        const response = await openai.chat.completions.create({
          model: 'gpt-3.5-turbo',
          messages: [
            { role: 'system', content: systemPrompt },
            { role: 'user', content: userPrompt },
          ],
        })

        // 5) Log and parse the response
        const content = response.choices[0]?.message?.content || ''
        logger.info('[OpenAI Sentiment Analyzer] Raw response', { content })

        let parsed: { sentiment?: string; analysis?: string } = {}
        try {
          parsed = JSON.parse(content.trim())
        } catch (err) {
          logger.error('[OpenAI Sentiment Analyzer] Unable to parse JSON', { error: err })
          // If it's not JSON, we bail or handle differently
          return
        }

        // 6) Decide how to route the event
        if (parsed.sentiment?.toLowerCase() === 'positive') {
          await emit({
            topic: 'openai.positiveSentiment',
            data: { ...parsed },
          })
        } else {
          // default to negative
          await emit({
            topic: 'openai.negativeSentiment',
            data: { ...parsed },
          })
        }
      } catch (err: any) {
        logger.error('[OpenAI Sentiment Analyzer] Error calling OpenAI', { error: err.message })
      }
    }
    ```

  </Tab>
  <Tab value="handlePositive">
    ```ts
    // Handles "openai.positiveSentiment"
    import { EventConfig, StepHandler } from 'motia'
    import { z } from 'zod'

    export const config: EventConfig = {
      type: 'event',
      name: 'Positive Sentiment Responder',
      subscribes: ['openai.positiveSentiment'],
      emits: [],
      input: z.object({
        sentiment: z.string(),
        analysis: z.string().optional(),
      }),
      flows: ['sentiment-demo'],
    }

    export const handler: StepHandler<typeof config> = async (input, { logger }) => {
      logger.info('[Positive Responder] The sentiment is positive!', { analysis: input.analysis })
      // Maybe notify a Slack channel: "All good vibes here!"
    }
    ```

  </Tab>
  <Tab value="handleNegative">
    ```ts
    // Handles "openai.negativeSentiment"
    import { EventConfig, StepHandler } from 'motia'
    import { z } from 'zod'

    export const config: EventConfig = {
      type: 'event',
      name: 'Negative Sentiment Responder',
      subscribes: ['openai.negativeSentiment'],
      emits: [],
      input: z.object({
        sentiment: z.string(),
        analysis: z.string().optional(),
      }),
      flows: ['sentiment-demo'],
    }

    export const handler: StepHandler<typeof config> = async (input, { logger }) => {
      logger.info('[Negative Responder] The sentiment is negative or unknown.', { analysis: input.analysis })
      // Could escalate to a service, or respond gently, etc.
    }
    ```

  </Tab>
</Tabs>

---

## Visual Overview

Here's how the events chain together:

<div className="my-8">![Flow: Sentiment Analysis Steps](./../img/sentiment-analyzer.png)</div>

1. **Analyze Sentiment (API)** → emits `openai.analyzeSentimentRequest`
2. **OpenAI Sentiment Analyzer** → calls OpenAI, parses JSON →
   - If `sentiment: "positive"` → emits `openai.positiveSentiment`
   - Else → emits `openai.negativeSentiment`
3. **Positive Sentiment Responder** or **Negative Sentiment Responder**

---

## Trying It Out

<Steps>

### Install Dependencies

```shell
pnpm install motia openai
```

### Create Project Structure

<Folder name="steps" defaultOpen>
  <File name="analyzeSentimentApi.step.ts" />
  <File name="openAiAnalyzeSentiment.step.ts" />
  <File name="handlePositive.step.ts" />
  <File name="handleNegative.step.ts" />
</Folder>

### Set Environment Variables

```shell
export OPENAI_API_KEY="sk-..."
```

### Run the Project

```shell
pnpm motia dev
```

### Test the API

```shell
curl -X POST http://localhost:3000/api/analyze-sentiment \
  -H "Content-Type: application/json" \
  -d '{"text":"I absolutely love this new device!"}'
```

Check your logs - you should see either the `[Positive Responder]` or `[Negative Responder]` step firing, depending on the LLM's JSON output.

### Extend Further

Here are some ways to build upon this example:

- Tweak the system instructions to force certain outputs or include more details
- Create more specialized responders (like "neutralSentiment")
- Integrate a notification step (Slack, database, etc.)

</Steps>

Try it out, see the branching logic in action, and enjoy skipping all the boring boilerplate!



## Examples
[Dynamic Sentiment Analysis](/llm-docs/examples/sentiment-analysis.md): Code example
---
title: Dynamic Sentiment Analysis
---

Sometimes you don't just want a **simple** "prompt => response." Instead, you want the LLM to decide how to proceed. Below is a minimal example that:

1. Receives user input via `POST /api/analyze-sentiment`
2. Calls OpenAI and **instructs** the LLM to return JSON with a `sentiment` field
3. Parses that JSON and **emits** different events depending on whether `sentiment` is `"positive"` or `"negative"` (or anything else)
4. Two specialized responders handle each sentiment separately

---

## The Steps

<Folder name="steps" defaultOpen>
  <File name="analyzeSentimentApi.step.ts" />
  <File name="openAiAnalyzeSentiment.step.ts" />
  <File name="handlePositive.step.ts" />
  <File name="handleNegative.step.ts" />
</Folder>

<Tabs items={['analyzeSentimentApi', 'openAiAnalyzeSentiment', 'handlePositive', 'handleNegative']}>
  <Tab value="analyzeSentimentApi">
    ```ts
    // Receives user text, emits "openai.analyzeSentimentRequest".
    import { ApiRouteConfig, StepHandler } from 'motia'
    import { z } from 'zod'

    export const config: ApiRouteConfig = {
      type: 'api',
      name: 'Analyze Sentiment (API)',
      path: '/api/analyze-sentiment',
      method: 'POST',
      emits: ['openai.analyzeSentimentRequest'],
      bodySchema: z.object({
        text: z.string().min(1, 'text is required'),
      }),
      flows: ['sentiment-demo'],
    }

    export const handler: StepHandler<typeof config> = async (req, { emit, logger }) => {
      const { text } = req.body

      logger.info('[AnalyzeSentimentAPI] Received text', { text })

      // Emit an event to call OpenAI
      await emit({
        topic: 'openai.analyzeSentimentRequest',
        data: { text },
      })

      // Return right away
      return {
        status: 200,
        body: { status: 'Accepted', message: 'Your text is being analyzed' },
      }
    }
    ```

  </Tab>
  <Tab value="openAiAnalyzeSentiment">
    ```ts
    // Calls OpenAI, instructing it to ONLY return JSON like {"sentiment":"positive","analysis":"..."}
    import { EventConfig, StepHandler } from 'motia'
    import { z } from 'zod'
    import { OpenAI } from 'openai'

    // 1) Create an OpenAI client (newer syntax)
    const openai = new OpenAI({ apiKey: process.env.OPENAI_API_KEY })

    export const config: EventConfig = {
      type: 'event',
      name: 'OpenAI Sentiment Analyzer',
      subscribes: ['openai.analyzeSentimentRequest'],
      // We'll emit different events: "openai.positiveSentiment" or "openai.negativeSentiment"
      emits: ['openai.positiveSentiment', 'openai.negativeSentiment'],
      input: z.object({ text: z.string() }),
      flows: ['sentiment-demo'],
    }

    // 3) Provide the code that runs on each event
    export const handler: StepHandler<typeof config> = async (input, { emit, logger }) => {
      logger.info('[OpenAI Sentiment Analyzer] Prompting OpenAI...', { text: input.text })

      try {
        // We'll ask the model to ONLY return JSON with a "sentiment" field
        const systemPrompt =
          'You are an assistant that returns only JSON: {"sentiment":"positive|negative","analysis":"..."}'
        const userPrompt = `Analyze the sentiment of this text: "${input.text}". Return JSON with keys "sentiment" and "analysis".`

        // 4) Use the new openai syntax:
        const response = await openai.chat.completions.create({
          model: 'gpt-3.5-turbo',
          messages: [
            { role: 'system', content: systemPrompt },
            { role: 'user', content: userPrompt },
          ],
        })

        // 5) Log and parse the response
        const content = response.choices[0]?.message?.content || ''
        logger.info('[OpenAI Sentiment Analyzer] Raw response', { content })

        let parsed: { sentiment?: string; analysis?: string } = {}
        try {
          parsed = JSON.parse(content.trim())
        } catch (err) {
          logger.error('[OpenAI Sentiment Analyzer] Unable to parse JSON', { error: err })
          // If it's not JSON, we bail or handle differently
          return
        }

        // 6) Decide how to route the event
        if (parsed.sentiment?.toLowerCase() === 'positive') {
          await emit({
            topic: 'openai.positiveSentiment',
            data: { ...parsed },
          })
        } else {
          // default to negative
          await emit({
            topic: 'openai.negativeSentiment',
            data: { ...parsed },
          })
        }
      } catch (err: any) {
        logger.error('[OpenAI Sentiment Analyzer] Error calling OpenAI', { error: err.message })
      }
    }
    ```

  </Tab>
  <Tab value="handlePositive">
    ```ts
    // Handles "openai.positiveSentiment"
    import { EventConfig, StepHandler } from 'motia'
    import { z } from 'zod'

    export const config: EventConfig = {
      type: 'event',
      name: 'Positive Sentiment Responder',
      subscribes: ['openai.positiveSentiment'],
      emits: [],
      input: z.object({
        sentiment: z.string(),
        analysis: z.string().optional(),
      }),
      flows: ['sentiment-demo'],
    }

    export const handler: StepHandler<typeof config> = async (input, { logger }) => {
      logger.info('[Positive Responder] The sentiment is positive!', { analysis: input.analysis })
      // Maybe notify a Slack channel: "All good vibes here!"
    }
    ```

  </Tab>
  <Tab value="handleNegative">
    ```ts
    // Handles "openai.negativeSentiment"
    import { EventConfig, StepHandler } from 'motia'
    import { z } from 'zod'

    export const config: EventConfig = {
      type: 'event',
      name: 'Negative Sentiment Responder',
      subscribes: ['openai.negativeSentiment'],
      emits: [],
      input: z.object({
        sentiment: z.string(),
        analysis: z.string().optional(),
      }),
      flows: ['sentiment-demo'],
    }

    export const handler: StepHandler<typeof config> = async (input, { logger }) => {
      logger.info('[Negative Responder] The sentiment is negative or unknown.', { analysis: input.analysis })
      // Could escalate to a service, or respond gently, etc.
    }
    ```

  </Tab>
</Tabs>

---

## Visual Overview

Here's how the events chain together:

<div className="my-8">![Flow: Sentiment Analysis Steps](./../img/sentiment-analyzer.png)</div>

1. **Analyze Sentiment (API)** → emits `openai.analyzeSentimentRequest`
2. **OpenAI Sentiment Analyzer** → calls OpenAI, parses JSON →
   - If `sentiment: "positive"` → emits `openai.positiveSentiment`
   - Else → emits `openai.negativeSentiment`
3. **Positive Sentiment Responder** or **Negative Sentiment Responder**

---

## Trying It Out

<Steps>

### Install Dependencies

```shell
pnpm install motia openai
```

### Create Project Structure

<Folder name="steps" defaultOpen>
  <File name="analyzeSentimentApi.step.ts" />
  <File name="openAiAnalyzeSentiment.step.ts" />
  <File name="handlePositive.step.ts" />
  <File name="handleNegative.step.ts" />
</Folder>

### Set Environment Variables

```shell
export OPENAI_API_KEY="sk-..."
```

### Run the Project

```shell
pnpm motia dev
```

### Test the API

```shell
curl -X POST http://localhost:3000/api/analyze-sentiment \
  -H "Content-Type: application/json" \
  -d '{"text":"I absolutely love this new device!"}'
```

Check your logs - you should see either the `[Positive Responder]` or `[Negative Responder]` step firing, depending on the LLM's JSON output.

### Extend Further

Here are some ways to build upon this example:

- Tweak the system instructions to force certain outputs or include more details
- Create more specialized responders (like "neutralSentiment")
- Integrate a notification step (Slack, database, etc.)

</Steps>

Try it out, see the branching logic in action, and enjoy skipping all the boring boilerplate!


-   [core-concepts](/llm-docs/getting-started/core-concepts.md): Documentation for core-concepts.
---
title: Core Concepts
description: Understand the fundamental concepts behind Motia.
---

# Building Blocks of Motia

To effectively build and utilize Motia, it's essential to grasp its foundational concepts. Motia workflows are built upon three building blocks that work together to create powerful and flexible automation solutions: **API**, **Event**, **Cron**, **Noop**. They're all represented as **Steps**.

## Everything is a Step

As mentioned above, Motia has four primitives, API Step, Event Step, Cron Step, Noop Steps. They're all steps on a Workflow and can be connected.

## What is a Step?

Steps are arbitraty executable functions that run based on a certain criteria.

1. **API Steps**: Run whenever an HTTP endpoint defined in your workflow is called. These steps allow external systems or clients to trigger automated processes within Motia.
2. **Event Steps**: Run whenever an event is emitted to a subscribed topic. These steps allow your workflow to react to changes or actions occurring within the Motia system.
3. **Cron Steps**: Run automatically based on a defined schedule, such as "every day at 1pm", according to a cron expression. These steps are ideal for automating recurring tasks.
4. **Noop Steps**: "Noop" stands for "No operation." These steps contain no logic and are used to represent actions that occur outside the Motia ecosystem, such as manual tasks or external processes.

## Example Step Types

- **API Step:** Exposes an HTTP endpoint to trigger a flow from external systems.
- **Event Step:** Executes logic in response to a specific event within the Motia system.
- **Cron Step:** Schedules tasks to run at specific intervals based on cron expressions.
- **Noop Step:** Represents a placeholder for external processes or manual tasks, useful for visualization and workflow modeling.

**➡️ [Learn More about Defining Steps](/docs/concepts/steps/defining-steps)**

## Flows: Orchestrating Your Workflows

Steps are connected through topics. For example, an API Step can emit a message to a topic, which an Event Step subscribes to and reacts upon. By chaining these connections, you create a flow—where step A triggers step B, which then triggers step C, and so on.

**Flows** provide a logical structure for organizing and managing your Steps. A Flow represents a complete automation process, grouping together the Steps that work together to achieve a specific goal.

### Key Aspects of Flows

- **Organization:** Flows help you structure complex automations by grouping related Steps, making your workflows easier to understand and manage.
- **Visualization:** Motia Workbench uses Flows to visually represent your workflows as interactive diagrams, showing the connections and event flow between Steps.
- **Context and Scope:** Flows define a context for Steps, allowing for flow-specific configurations, logging, and state management.
- **Event Namespacing:** Events are often scoped within a Flow, ensuring that events emitted in one flow are less likely to interfere with events in another.

### Example Flow Scenarios

- **Order Processing Flow:** Steps for order validation, payment processing, inventory updates, and shipping notifications.
- **User Onboarding Flow:** Steps for account creation, email verification, welcome messages, and initial setup tasks.
- **Data Synchronization Flow:** Steps for fetching data from an external source, transforming it, and updating a database.

### Virtually connecting steps

Sometimes, a workflow needs to represent actions that occur outside the Motia ecosystem—such as manual tasks or
external processes—to make the flow comprehensive and easy to understand. In these cases, you can use Noop Steps
to create virtual connections between steps, ensuring your flow remains visually and logically complete.

**Example: Content Creation Workflow**

1. Article is created by a user
2. Article needs to be reviewed by a moderator
3. The moderator approves it, making the article public and listed somewhere.

In this example, step 2 (moderator review) is a virtual connection between steps 1 and 3.
This can be represented by a Noop Step:

```
┌──────────────────┐      ┌─────────────────────┐      ┌────────────────────────────┐
│  POST /article   │ ───► │  Moderator review   │ ───► │  POST /article/:id/review  │
└──────────────────┘      └─────────────────────┘      └────────────────────────────┘
```

Without a Noop Step, the other two steps would appear disconnected, which could lead to confusion in the flow diagram.
By including a Noop Step, you maintain clarity and accurately represent the entire process, even when some actions
happen outside of Motia.

---

By understanding these core concepts – you'll have a solid foundation for building powerful and maintainable automation workflows with Motia. Continue exploring the documentation to delve deeper into each concept and start building your own amazing automations!


-   [index](/llm-docs/getting-started/index.md): Documentation for index.
---
title: Getting Started
description: Get started with Motia - Unified Backend Framework for APIs, Events and AI Agents
---

# Your Path to Intelligent Workflow Automation

Welcome to Motia!  Ready to build your first event-driven workflow? This guide will take you through the initial steps to get your Motia development environment set up and start building!

## In This Getting Started Guide, You'll Discover:

- **Effortless Installation:** Learn how to quickly install Motia and set up your development environment with minimal hassle.
- **Core Concepts Demystified:**  Understand the fundamental building blocks of Motia – Steps, Flows, Events, and Topics – in a clear and accessible way.
- **Your First Automation Flow - Step-by-Step:**  Build a simple yet functional automation workflow from scratch, getting hands-on experience with Motia's core features.
- **Environment Configuration Made Easy:**  Master the essential configurations to tailor Motia to your development needs and preferences.

## Prerequisites

Before you begin, ensure you have the following installed:

- **Node.js (v16.0 or later):** Motia runs on Node.js, so this is essential for running the development server and your workflows.
- **Basic Understanding of programming:**  motia steps are written in Javascript, Typescript, and/or Python.
- **Basic Understanding of React:**  While you don't need to be a React expert, a basic familiarity will be helpful for understanding the UI Workbench and customizing UI steps.

## Your Next Steps:

1.  **Quick Start Guide:** [Build Your First Flow](/docs/getting-started/quick-start) -  Follow our step-by-step guide to create a minimal Motia workflow and see it in action.
2.  **Core Concepts:** [Understand the Fundamentals](/docs/getting-started/core-concepts) -  Dive deeper into the essential concepts of Motia: Steps, Flows, Events, and Topics.

-   [Quick Start](/llm-docs/getting-started/quick-start.md): Documentation for Quick Start.
---
title: Quick Start
---

This guide will walk you through everything you need to define a minimal **step**, set up your Motia project, and run the **Motia** dev server – all in one go, using **pnpm** for package management.

<Steps>
  <Step>
  ### Setup your project: Create a New Project Folder

Let's create a new Motia project in a dedicated folder. This is the recommended approach for keeping your projects organized.

  <Tabs items={['Automated', 'Manual']}>
<Tab value="Automated">
  <Tabs items={['npx', 'motia Global CLI']}>
    <Tab value="npx">
      Use `npx` to run the project creation command directly:

      <Tabs items={['npx']}>
        <Tab value="npx">
          ```bash
          npx motia@latest create -n <your-project-name>
          ```
        </Tab>
      </Tabs>
    </Tab>

    <Tab value="motia Global CLI">
      **First, install the Motia CLI globally:**

      <Tabs items={['pnpm (Global)', 'npm (Global)', 'yarn (Global)', 'bun (Global)']}>
        <Tab value="pnpm (Global)">
          ```bash
          npm install -g motia
          ```
        </Tab>
        <Tab value="npm (Global)">
          ```bash
          npm install -g motia
          ```
        </Tab>
        <Tab value="yarn (Global)">
          ```bash
          yarn global add motia
          ```
        </Tab>
        <Tab value="bun (Global)">
          ```bash
          bun add -g motia
          ```
        </Tab>
      </Tabs>

      **Then, create your project using the globally installed `motia` command:**

      ```bash
      motia create -n <your-project-name>
      ```
    </Tab>

  </Tabs>

    *   **This will**:
        *   Download and run the Motia CLI project creation tool
        *   Create a new project directory named `<your-project-name>`.
        *   Set up a basic Motia project structure inside the new folder.
        *   Install necessary dependencies using pnpm within the project folder.
        *   Add a `dev` script to your `package.json`.
        *   Include example steps to get you started.

  <Callout type="info">
    **Choosing a Project Name:** Replace `<your-project-name>` with your desired project folder name.

    **Alternative Templates:** To see other templates, run: `npx motia templates` (or `motia templates` if you installed globally).

  </Callout>

You should see a new folder created with the following files inside:

  <Files>
    <Folder name="steps" defaultOpen>
      <File name="00-noop.step.ts" />
      <File name="00-noop.step.tsx" />
      <File name="01-api.step.ts" />
      <File name="02-test-state.step.ts" />
      <File name="03-check-state-change.step.ts" />
    </Folder>
    <File name="package.json" />
    <File name="tsconfig.json" />
    <File name="types.d.ts" />
  </Files>
</Tab>
    <Tab value="Manual">
      <Callout>For these instructions we recommend using `pnpm`. For detailed installation instructions and package manager options, please refer to the [Installation Guide](/docs/getting-started/installation) (Note: In this Quick Start, automated project creation is highly recommended).</Callout>

      **Quick Setup Summary (Manual - Advanced Users):**

      1.  **Create a project directory:**
          ```bash
          mkdir <your-project-name> && cd <your-project-name>
          ```

      2.  **Initialize `package.json`:**
          ```bash
          npm init -y
          ```

      3.  **Install Core Packages:**
          ```bash
            motia zod
          ```

      4.  **Add `dev` Script to `package.json`:**
          ```json
          {
            "scripts": {
              "dev": "motia dev"
            }
          }
          ```

      5.  **Optional TypeScript Setup:**
          ```bash
          ts-node typescript -D
          ```

      6.  **Create `steps` Folder:**
          ```bash
          mkdir steps
          ```
    </Tab>

  </Tabs>

  </Step>
  <Step>
  ### Minimal Step Example

**The initial project comes with sample steps, but in this step we're going to walk you through on creating a new one**

1.  **Create a new file** named `hello-world.step.js` (or `hello-world.step.ts` for TypeScript) inside the `steps` folder.

    <Files>
      <Folder name="steps" defaultOpen>
        <File name="hello-world.step.js" />
      </Folder>
    </Files>

2.  **Paste the following code** into your `hello-world.step.js` file:

        ```javascript
        exports.config = {
          type: 'api', // "event", "api", or "cron"
          path: '/hello-world',
          method: 'GET',
          name: 'HelloWorld',
          emits: [],
          flows: ['HelloWorld'],
        }

        exports.handler = async () => {
          return {
            status: 200,
            body: { message: 'Hello World' },
          }
        }
        ```
        This minimal API step creates a **GET** endpoint on `/hello-world` that returns a JSON

        ```json
        { "message": "Hello World" }
        ```

  </Step>

   <Step>

### Start Motia Development Server & Workbench

Now, let's start Motia and see your workflow in action!

1.  **Open your terminal** in your Motia project's root directory (where your `package.json` file is located).

2.  **Run the development server command:** Use the `dev` script that was set up in your `package.json`:

    <Tabs items={['npm', 'yarn', 'pnpm', 'bun']}>
      <Tab value="yarn">```yarn run dev ```</Tab>
      <Tab value="npm">```npm run dev ```</Tab>
      <Tab value="pnpm">```pnpm run dev ```</Tab>
      <Tab value="bun">```bun run dev ```</Tab>
    </Tabs>

    Motia will:

    - **Scan** your `steps` folder for step definition files (`.step.ts`, `.step.js`, `.step.py`, `.step.rb`).
    - **Register** your Steps with the Motia runtime.
    - **Launch** a development server and the Motia Workbench UI (typically at [`http://localhost:3000`](http://localhost:3000)).

    <Callout type="info">
      **Changing the Port:** To run the Workbench on a different port, use the `--port` option: `pnpm run dev --port
      3001`
    </Callout>

  </Step>
  <Step>
    ### View your Flow in the Workbench

    1.  **Open your browser** and navigate to the Motia Workbench.  By default, it's running at:  [`http://localhost:3000`](http://localhost:3000) or [`http://127.0.0.1:3000`](http://127.0.0.1:3000).

    2.  **Locate your Flow in the Sidebar:** On the left sidebar of the Workbench UI, you should see a list of Flows.

        *   **For the default template:**  You'll find a flow named "**default**".
        *   **For the `hello-world.step.js` example:** You'll find a flow named "**HelloWorld**".

    3.  **Select your Flow:** Click on the flow name in the sidebar.

    4.  **Observe the Visual Flow:** You should now see a visual representation of your flow in the main panel. This is the Motia Workbench visualizing the steps and event flow within your application!

        ![Flow Visualization in Workbench](./../img/hello-world-workbench.png)

        <Callout type="info">
            You can click and drag the nodes in the visual editor to rearrange them for better clarity. Explore the UI to familiarize yourself with the Workbench!
        </Callout>

    </Step>
    <Step>
    ### Test your step

    Now you created the step `hello-world.js`, which creates a **GET** `/hello-world` endpoint, you can test by either opening http://localhost:3000/hello-world or

    ```bash
    curl http://localhost:3000/hello-world
    ```

    This is a really simple example where you can have your first step running.

    </Step>

    <Step>
    ### Understanding a flow with events

    Now you already created an API Steps, let's check the flow that's already in the project, click on `default` flow on Workbench sidebar on the left. (Or navigate to http://localhost:3000/flow/default)

    You should see the page below

    ![Flow Visualization in Workbench](./../img/getting-started-workbench.png)

    This flow is a little bit more advanced, it has Noop steps (which we are going to talk about later), API steps, and Event steps.

    Event steps are code that can take some time to finish and can have errors (like LLM calls which are non-deterministic), in case they fail, they can rerun later.

    In the flow represented by the image above you should see a node with a button to start it, go ahead an click it and check the logs that are generated.

    Now let's dive deep on the flow you already executed. Let's jump in to [Core concepts](/docs/getting-started/core-concepts)

    </Step>

</Steps>


-   [index](/llm-docs/index.md): Documentation for index.
---
title: Welcome to Motia
description: Get started with Motia, a powerful framework for building event-driven workflows
---

# Unified Backend Framework for APIs, Events and AI Agents

Motia is a **code-first framework** designed to empower developers to build robust, scalable, and observable event-driven workflows with unparalleled ease. We handle the infrastructure complexities, so you can focus on your business logic.

## Why Choose Motia?

Motia is built with the developer in mind, offering a unique blend of simplicity and power. Here's why Motia stands out:

- 🚀 **Zero Infrastructure Setup:** Say goodbye to the complexities of message queues and event brokers! Motia handles the underlying infrastructure, allowing you to focus solely on building your workflows.
- 🔌 **Plug-and-Play Steps in Your Language:** Develop your workflow logic using the languages you love: JavaScript, TypeScript, and Python. Mix and match languages within the same flow for ultimate flexibility.
- 📊 **Built-in Observability:** Gain deep insights into your workflows with real-time logs, traces, and interactive flow visualizations right in the Motia Workbench. Debugging and monitoring have never been easier.
- ⚡ **Out-of-the-Box API & Scheduling:** Instantly expose your workflows as HTTP endpoints and schedule tasks with cron expressions – no extra configuration needed.
- ✨ **Flexible and Extensible Architecture:** Motia is designed to be easily extended and customized. Create custom steps, UI components, and adapt the framework to your specific needs.
- 🧑‍💻 **Developer-First Experience:** From intuitive APIs and a powerful CLI to comprehensive documentation and a visual workbench, Motia prioritizes developer productivity and a smooth, enjoyable development experience.

## Motia Workbench: Your Development Control Center

Motia Workbench is a built-in, browser-based development platform that acts as your central hub for building, testing, and debugging Motia flows. Key features include:

- **Interactive Flow Visualization:** See your workflows come to life as dynamic diagrams, making it easy to understand complex event flows and step interactions.

- **Real-time Flow Testing:** Trigger API endpoints and monitor event propagation through your steps, all within the Workbench UI. Inspect data at each stage to ensure your flows are behaving as expected.

- **Live Log Streaming:** Access detailed, real-time logs directly in the Workbench. Filter and search logs to quickly pinpoint issues and monitor workflow execution.

- **Step-Level Customization:** Create custom UI components for your steps to enhance visualization and provide context-specific information directly within the flow diagram.

<div className="my-8">![Motia Workbench Interface](./img/workbench-presentation.png)</div>

## Unlock Powerful Use Cases

Motia empowers you to build a wide range of sophisticated applications, including:

- 🌐 **API Integrations & Microservices:** Effortlessly connect disparate systems, create event-driven microservices, and build real-time API-powered applications.

- 🤖 **Intelligent & Agentic Workflows:** Design complex, AI-driven workflows, orchestrate intricate business processes, and build advanced data pipelines.

- 📊 **Data Transformation & Processing:** Build scalable ETL/ELT pipelines, implement real-time data streaming, and transform data with ease.

- 🚀 **Rapid Prototyping & Iteration:** Quickly bring your ideas to life, test new workflows, and iterate rapidly with Motia's visual design and development tools.

### Real-World Industry Applications

Motia is versatile and can be applied across various industries and use cases, such as:

- **E-commerce:** Order processing, inventory synchronization, fraud detection, customer communication automation.
- **Finance:** Trade settlement, risk analysis, compliance monitoring, automated reporting.
- **Healthcare:** Clinical trial management, claims processing, patient monitoring, appointment scheduling.
- **Marketing:** Lead scoring, personalized campaign orchestration, sentiment analysis, social media automation.
- **And much more!**

## Ready to Get Started?

Embark on your Motia journey and start building powerful workflows today:

1.  **Quick Start Guide:** Follow our [Quick Start](/docs/getting-started/quick-start) to set up your first Motia project and create a minimal workflow.
2.  **Explore Examples:** Dive into practical [Examples](/docs/examples) to understand common patterns and real-world use cases.
3.  **Dive into Concepts:** Delve deeper into Motia's [Core Concepts](/docs/getting-started/core-concepts) to gain a solid understanding of the framework's architecture and principles.

## Join the Motia Community

Become part of a growing community of developers and automation enthusiasts!

- 💬 **Join our Discord:** Connect with the Motia team and fellow developers, ask questions, share ideas, and get real-time help: [Discord Community](https://discord.gg/nJFfsH5d6v)
- 🐙 **Star us on GitHub:** Show your support, contribute to the project, and report issues on our [GitHub Repository](https://github.com/motiadev/motia).
- 🐦 **Follow us on Twitter:** Stay up-to-date with the latest news, announcements, and community updates: [Twitter (@motiadev)](https://twitter.com/motiadev)

We're excited to see what you'll build with Motia!


-   [ai-deep-research-agent](/llm-docs/real-world-use-cases/ai-deep-research-agent.md): Documentation for ai-deep-research-agent.
---
title: AI Deep Research Agent
description: A powerful research assistant that leverages the Motia Framework to perform comprehensive web research on any topic and any question.
---

import { CodeFetcher } from '../../../components/CodeFetcher'

## Let's build a AI Deep Research Agent that:

- **Deep Web Research**: Automatically searches the web, extracts content, and synthesizes findings
- **Iterative Research Process**: Supports multiple layers of research depth for comprehensive exploration
- **Event-Driven Architecture**: Built using Motia Framework's event system for robust workflow management
- **Parallel Processing**: Efficiently processes search results and content extraction
- **API Endpoints**: REST API access for initiating research and retrieving reports
- **Stateful Processing**: Maintains research state throughout the entire process

## The Steps

<Folder name="steps" defaultOpen>
  <File name="analyze-content.step.ts" />
  <File name="compile-report.step.ts" />
  <File name="extract-content.step.ts" />
  <File name="follow-up-research.step.ts" />
  <File name="generate-queries.step.ts" />
  <File name="report-api.step.ts" />
  <File name="research-api.step.ts" />
  <File name="search-web.step.ts" />
  <File name="status-api.step.ts" />
</Folder>

<Tabs items={['analyze-content', 'compile-report', 'extract-content', 'follow-up-research', 'generate-queries', 'report-api', 'research-api', 'search-web', 'status-api']}>
  <CodeFetcher path="examples/ai-deep-research-agent/steps" tab="analyze-content" value="analyze-content" />
  <CodeFetcher path="examples/ai-deep-research-agent/steps" tab="compile-report" value="compile-report" />
  <CodeFetcher path="examples/ai-deep-research-agent/steps" tab="extract-content" value="extract-content" />
  <CodeFetcher path="examples/ai-deep-research-agent/steps" tab="follow-up-research" value="follow-up-research" />
  <CodeFetcher path="examples/ai-deep-research-agent/steps" tab="generate-queries" value="generate-queries" />
  <CodeFetcher path="examples/ai-deep-research-agent/steps" tab="report-api" value="report-api" />
  <CodeFetcher path="examples/ai-deep-research-agent/steps" tab="research-api" value="research-api" />
  <CodeFetcher path="examples/ai-deep-research-agent/steps" tab="search-web" value="search-web" />
  <CodeFetcher path="examples/ai-deep-research-agent/steps" tab="status-api" value="status-api" />
</Tabs>

## 🚀 Features

- **Deep Web Research**: Automatically searches the web, extracts content, and synthesizes findings
- **Iterative Research Process**: Supports multiple layers of research depth for comprehensive exploration
- **Event-Driven Architecture**: Built using Motia Framework's event system for robust workflow management
- **Parallel Processing**: Efficiently processes search results and content extraction
- **API Endpoints**: REST API access for initiating research and retrieving reports
- **Stateful Processing**: Maintains research state throughout the entire process

## 📋 Prerequisites

- Node.js v18 or later
- npm or pnpm
- API keys for:
  - [OpenAI](https://platform.openai.com/) (AI analysis)
  - [Firecrawl](https://www.firecrawl.dev/) (Web Crawler)

## 🛠️ Installation

1. Clone the repository:
   ```bash
   git clone https://github.com/MotiaDev/motia-examples
   cd examples/ai-deep-research-agent
   ```

2. Install dependencies:
   ```bash
   pnpm install
   # or
   npm install
   ```

3. Configure environment variables:
   ```bash
   cp .env.example .env
   ```

   Update `.env` with your API keys:
   ```bash
   # Required
   OPENAI_API_KEY=your-openai-api-key-here
   FIRECRAWL_API_KEY=your-firecrawl-api-key-here

   # Optional
   # OPENAI_MODEL=gpt-4o
   # FIRECRAWL_BASE_URL=http://your-firecrawl-instance-url
   ```

## 🏗️ Architecture

![AI Deep Research Agent](../img/ai-deep-research-agent.png)


## 🚦 API Endpoints

### Start Research

```
POST /research
Content-Type: application/json

{
  "query": "The research topic or question",
  "breadth": 4,  // Number of search queries to generate (1-10)
  "depth": 2     // Depth of research iterations (1-5)
}
```

Response:
```json
{
  "message": "Research process started",
  "requestId": "unique-trace-id"
}
```

### Check Research Status

```
GET /research/status?requestId=unique-trace-id
```

Response:
```json
{
  "message": "Research status retrieved successfully",
  "requestId": "unique-trace-id",
  "originalQuery": "The research topic or question",
  "status": "in-progress",
  "progress": {
    "currentDepth": 1,
    "totalDepth": 2,
    "percentComplete": 50
  },
  "reportAvailable": false
}
```

### Get Research Report

```
GET /research/report?requestId=unique-trace-id
```

Response:
```json
{
  "message": "Research report retrieved successfully",
  "report": {
    "title": "Research Report Title",
    "overview": "Executive summary...",
    "sections": [
      {
        "title": "Section Title",
        "content": "Section content..."
      }
    ],
    "keyTakeaways": [
      "Key takeaway 1",
      "Key takeaway 2"
    ],
    "sources": [
      {
        "title": "Source Title",
        "url": "Source URL"
      }
    ],
    "originalQuery": "The research topic or question",
    "metadata": {
      "depthUsed": 2,
      "completedAt": "2025-03-18T16:45:30Z"
    }
  },
  "requestId": "unique-trace-id"
}
```

## 🏃‍♂️ Running the Application

1. Start the development server:
   ```bash
   pnpm dev
   ```

2. Access the Motia Workbench:
   ```
   http://localhost:3000
   ```

3. Make a test request:
   ```bash
   curl --request POST \
   --url http://localhost:3000/research \
   --header 'Content-Type: application/json' \
   --data '{
      "query": "Advancements in renewable energy storage",
      "depth": 1,
      "breadth": 1
   }'
   ```
## 🙏 Acknowledgments

- [Motia Framework](https://motia.dev) for the event-driven workflow engine
- [OpenAI](https://platform.openai.com/) for AI analysis 
- [Firecrawl](https://www.firecrawl.dev/) for Web search and content extraction API


## Use Cases
[ai-deep-research-agent](/llm-docs/real-world-use-cases/ai-deep-research-agent.md): Real world use case
---
title: AI Deep Research Agent
description: A powerful research assistant that leverages the Motia Framework to perform comprehensive web research on any topic and any question.
---

import { CodeFetcher } from '../../../components/CodeFetcher'

## Let's build a AI Deep Research Agent that:

- **Deep Web Research**: Automatically searches the web, extracts content, and synthesizes findings
- **Iterative Research Process**: Supports multiple layers of research depth for comprehensive exploration
- **Event-Driven Architecture**: Built using Motia Framework's event system for robust workflow management
- **Parallel Processing**: Efficiently processes search results and content extraction
- **API Endpoints**: REST API access for initiating research and retrieving reports
- **Stateful Processing**: Maintains research state throughout the entire process

## The Steps

<Folder name="steps" defaultOpen>
  <File name="analyze-content.step.ts" />
  <File name="compile-report.step.ts" />
  <File name="extract-content.step.ts" />
  <File name="follow-up-research.step.ts" />
  <File name="generate-queries.step.ts" />
  <File name="report-api.step.ts" />
  <File name="research-api.step.ts" />
  <File name="search-web.step.ts" />
  <File name="status-api.step.ts" />
</Folder>

<Tabs items={['analyze-content', 'compile-report', 'extract-content', 'follow-up-research', 'generate-queries', 'report-api', 'research-api', 'search-web', 'status-api']}>
  <CodeFetcher path="examples/ai-deep-research-agent/steps" tab="analyze-content" value="analyze-content" />
  <CodeFetcher path="examples/ai-deep-research-agent/steps" tab="compile-report" value="compile-report" />
  <CodeFetcher path="examples/ai-deep-research-agent/steps" tab="extract-content" value="extract-content" />
  <CodeFetcher path="examples/ai-deep-research-agent/steps" tab="follow-up-research" value="follow-up-research" />
  <CodeFetcher path="examples/ai-deep-research-agent/steps" tab="generate-queries" value="generate-queries" />
  <CodeFetcher path="examples/ai-deep-research-agent/steps" tab="report-api" value="report-api" />
  <CodeFetcher path="examples/ai-deep-research-agent/steps" tab="research-api" value="research-api" />
  <CodeFetcher path="examples/ai-deep-research-agent/steps" tab="search-web" value="search-web" />
  <CodeFetcher path="examples/ai-deep-research-agent/steps" tab="status-api" value="status-api" />
</Tabs>

## 🚀 Features

- **Deep Web Research**: Automatically searches the web, extracts content, and synthesizes findings
- **Iterative Research Process**: Supports multiple layers of research depth for comprehensive exploration
- **Event-Driven Architecture**: Built using Motia Framework's event system for robust workflow management
- **Parallel Processing**: Efficiently processes search results and content extraction
- **API Endpoints**: REST API access for initiating research and retrieving reports
- **Stateful Processing**: Maintains research state throughout the entire process

## 📋 Prerequisites

- Node.js v18 or later
- npm or pnpm
- API keys for:
  - [OpenAI](https://platform.openai.com/) (AI analysis)
  - [Firecrawl](https://www.firecrawl.dev/) (Web Crawler)

## 🛠️ Installation

1. Clone the repository:
   ```bash
   git clone https://github.com/MotiaDev/motia-examples
   cd examples/ai-deep-research-agent
   ```

2. Install dependencies:
   ```bash
   pnpm install
   # or
   npm install
   ```

3. Configure environment variables:
   ```bash
   cp .env.example .env
   ```

   Update `.env` with your API keys:
   ```bash
   # Required
   OPENAI_API_KEY=your-openai-api-key-here
   FIRECRAWL_API_KEY=your-firecrawl-api-key-here

   # Optional
   # OPENAI_MODEL=gpt-4o
   # FIRECRAWL_BASE_URL=http://your-firecrawl-instance-url
   ```

## 🏗️ Architecture

![AI Deep Research Agent](../img/ai-deep-research-agent.png)


## 🚦 API Endpoints

### Start Research

```
POST /research
Content-Type: application/json

{
  "query": "The research topic or question",
  "breadth": 4,  // Number of search queries to generate (1-10)
  "depth": 2     // Depth of research iterations (1-5)
}
```

Response:
```json
{
  "message": "Research process started",
  "requestId": "unique-trace-id"
}
```

### Check Research Status

```
GET /research/status?requestId=unique-trace-id
```

Response:
```json
{
  "message": "Research status retrieved successfully",
  "requestId": "unique-trace-id",
  "originalQuery": "The research topic or question",
  "status": "in-progress",
  "progress": {
    "currentDepth": 1,
    "totalDepth": 2,
    "percentComplete": 50
  },
  "reportAvailable": false
}
```

### Get Research Report

```
GET /research/report?requestId=unique-trace-id
```

Response:
```json
{
  "message": "Research report retrieved successfully",
  "report": {
    "title": "Research Report Title",
    "overview": "Executive summary...",
    "sections": [
      {
        "title": "Section Title",
        "content": "Section content..."
      }
    ],
    "keyTakeaways": [
      "Key takeaway 1",
      "Key takeaway 2"
    ],
    "sources": [
      {
        "title": "Source Title",
        "url": "Source URL"
      }
    ],
    "originalQuery": "The research topic or question",
    "metadata": {
      "depthUsed": 2,
      "completedAt": "2025-03-18T16:45:30Z"
    }
  },
  "requestId": "unique-trace-id"
}
```

## 🏃‍♂️ Running the Application

1. Start the development server:
   ```bash
   pnpm dev
   ```

2. Access the Motia Workbench:
   ```
   http://localhost:3000
   ```

3. Make a test request:
   ```bash
   curl --request POST \
   --url http://localhost:3000/research \
   --header 'Content-Type: application/json' \
   --data '{
      "query": "Advancements in renewable energy storage",
      "depth": 1,
      "breadth": 1
   }'
   ```
## 🙏 Acknowledgments

- [Motia Framework](https://motia.dev) for the event-driven workflow engine
- [OpenAI](https://platform.openai.com/) for AI analysis 
- [Firecrawl](https://www.firecrawl.dev/) for Web search and content extraction API

-   [finance-agent](/llm-docs/real-world-use-cases/finance-agent.md): Documentation for finance-agent.
---
title: Finance Agent
description: A powerful event-driven financial analysis workflow that combines web search, financial data, and AI analysis to provide comprehensive investment insights.
---

import { CodeFetcher } from '../../../components/CodeFetcher'

## Let's build a finance agent that:

- Real-time Financial Analysis: Combines multiple data sources for comprehensive insights
- AI-Powered Insights: Leverages OpenAI GPT-4 for intelligent market analysis
- Web Search Integration: Aggregates latest market news and analysis
- Financial Data Integration: Real-time stock and company information

## The Steps

<Folder name="steps" defaultOpen>
  <File name="finance-data.step.ts" />
  <File name="openai-analysis.step.ts" />
  <File name="query-api.step.ts" />
  <File name="response-coordinator.step.ts" />
  <File name="result-api.step.ts" />
  <File name="save-result.step.ts" />
  <File name="web-search.step.ts" />
</Folder>

<Tabs items={['finance-data', 'openai-analysis', 'query-api', 'response-coordinator', 'result-api', 'save-result', 'web-search']}>
  <CodeFetcher path="examples/finance-agent/steps" tab="finance-data" value="finance-data" />
  <CodeFetcher path="examples/finance-agent/steps" tab="openai-analysis" value="openai-analysis" />
  <CodeFetcher path="examples/finance-agent/steps" tab="query-api" value="query-api" />
  <CodeFetcher path="examples/finance-agent/steps" tab="response-coordinator" value="response-coordinator" />
  <CodeFetcher path="examples/finance-agent/steps" tab="result-api" value="result-api" />
  <CodeFetcher path="examples/finance-agent/steps" tab="save-result" value="save-result" />
  <CodeFetcher path="examples/finance-agent/steps" tab="web-search" value="web-search" />
</Tabs>

## 🚀 Features

- **Real-time Financial Analysis**: Combines multiple data sources for comprehensive insights
- **AI-Powered Insights**: Leverages OpenAI GPT-4 for intelligent market analysis
- **Event-Driven Architecture**: Built on Motia's robust event system for reliable processing
- **Web Search Integration**: Aggregates latest market news and analysis
- **Financial Data Integration**: Real-time stock and company information
- **Persistent Storage**: Stores analysis results for future reference
- **RESTful API**: Easy integration with existing systems

## 📋 Prerequisites

- Node.js v16+
- npm or pnpm
- API keys for:
  - [Alpha Vantage](https://www.alphavantage.co/) (financial data)
  - [SerperDev](https://serper.dev/) (web search)
  - [OpenAI](https://platform.openai.com/) (AI analysis)

## 🛠️ Installation

1. Clone the repository:
   ```bash
   git clone https://github.com/MotiaDev/motia-examples
   cd examples/finance-agent
   ```

2. Install dependencies:
   ```bash
   pnpm install
   # or
   npm install
   ```

3. Configure environment variables:
   ```bash
   cp .env.example .env
   ```

   Update `.env` with your API keys:
   ```bash
   ALPHA_VANTAGE_API_KEY=your_alpha_vantage_api_key_here
   SERPER_API_KEY=your_serper_api_key_here
   OPENAI_API_KEY=your_openai_api_key_here
   ```

## 🏗️ Architecture

The workflow consists of several specialized steps that work together to provide comprehensive financial analysis:

![Finance Agent](../img/finance-agent.png)


## 🚦 API Endpoints

### Query Endpoint

```http
POST /finance-query
Content-Type: application/json

{
  "query": "Latest information about AAPL and MSFT"
}
```

Response:
```json
{
  "message": "Query received and processing started",
  "traceId": "abc123def456"
}
```

### Results Endpoint

```http
GET /finance-result/:traceId
```

Response:
```json
{
  "query": "Latest information about AAPL and MSFT",
  "timestamp": "2023-06-15T12:34:56.789Z",
  "response": {
    "summary": "Results for \"Latest information about AAPL and MSFT\"",
    "webResources": [...],
    "financialData": [...],
    "aiAnalysis": {...}
  },
  "status": "success"
}
```

## 🏃‍♂️ Running the Application

1. Start the development server:
   ```bash
   pnpm dev
   ```

2. Access the Motia Workbench:
   ```
   http://localhost:3000
   ```

3. Make a test request:
   ```bash
   curl -X POST http://localhost:3000/finance-query \
     -H "Content-Type: application/json" \
     -d '{"query": "Latest information about AAPL and MSFT"}'
   ```
## 🙏 Acknowledgments

- [Motia Framework](https://motia.dev) for the event-driven workflow engine
- [Alpha Vantage](https://www.alphavantage.co/) for financial data
- [SerperDev](https://serper.dev/) for web search capabilities
- [OpenAI](https://platform.openai.com/) for AI analysis 


## Use Cases
[finance-agent](/llm-docs/real-world-use-cases/finance-agent.md): Real world use case
---
title: Finance Agent
description: A powerful event-driven financial analysis workflow that combines web search, financial data, and AI analysis to provide comprehensive investment insights.
---

import { CodeFetcher } from '../../../components/CodeFetcher'

## Let's build a finance agent that:

- Real-time Financial Analysis: Combines multiple data sources for comprehensive insights
- AI-Powered Insights: Leverages OpenAI GPT-4 for intelligent market analysis
- Web Search Integration: Aggregates latest market news and analysis
- Financial Data Integration: Real-time stock and company information

## The Steps

<Folder name="steps" defaultOpen>
  <File name="finance-data.step.ts" />
  <File name="openai-analysis.step.ts" />
  <File name="query-api.step.ts" />
  <File name="response-coordinator.step.ts" />
  <File name="result-api.step.ts" />
  <File name="save-result.step.ts" />
  <File name="web-search.step.ts" />
</Folder>

<Tabs items={['finance-data', 'openai-analysis', 'query-api', 'response-coordinator', 'result-api', 'save-result', 'web-search']}>
  <CodeFetcher path="examples/finance-agent/steps" tab="finance-data" value="finance-data" />
  <CodeFetcher path="examples/finance-agent/steps" tab="openai-analysis" value="openai-analysis" />
  <CodeFetcher path="examples/finance-agent/steps" tab="query-api" value="query-api" />
  <CodeFetcher path="examples/finance-agent/steps" tab="response-coordinator" value="response-coordinator" />
  <CodeFetcher path="examples/finance-agent/steps" tab="result-api" value="result-api" />
  <CodeFetcher path="examples/finance-agent/steps" tab="save-result" value="save-result" />
  <CodeFetcher path="examples/finance-agent/steps" tab="web-search" value="web-search" />
</Tabs>

## 🚀 Features

- **Real-time Financial Analysis**: Combines multiple data sources for comprehensive insights
- **AI-Powered Insights**: Leverages OpenAI GPT-4 for intelligent market analysis
- **Event-Driven Architecture**: Built on Motia's robust event system for reliable processing
- **Web Search Integration**: Aggregates latest market news and analysis
- **Financial Data Integration**: Real-time stock and company information
- **Persistent Storage**: Stores analysis results for future reference
- **RESTful API**: Easy integration with existing systems

## 📋 Prerequisites

- Node.js v16+
- npm or pnpm
- API keys for:
  - [Alpha Vantage](https://www.alphavantage.co/) (financial data)
  - [SerperDev](https://serper.dev/) (web search)
  - [OpenAI](https://platform.openai.com/) (AI analysis)

## 🛠️ Installation

1. Clone the repository:
   ```bash
   git clone https://github.com/MotiaDev/motia-examples
   cd examples/finance-agent
   ```

2. Install dependencies:
   ```bash
   pnpm install
   # or
   npm install
   ```

3. Configure environment variables:
   ```bash
   cp .env.example .env
   ```

   Update `.env` with your API keys:
   ```bash
   ALPHA_VANTAGE_API_KEY=your_alpha_vantage_api_key_here
   SERPER_API_KEY=your_serper_api_key_here
   OPENAI_API_KEY=your_openai_api_key_here
   ```

## 🏗️ Architecture

The workflow consists of several specialized steps that work together to provide comprehensive financial analysis:

![Finance Agent](../img/finance-agent.png)


## 🚦 API Endpoints

### Query Endpoint

```http
POST /finance-query
Content-Type: application/json

{
  "query": "Latest information about AAPL and MSFT"
}
```

Response:
```json
{
  "message": "Query received and processing started",
  "traceId": "abc123def456"
}
```

### Results Endpoint

```http
GET /finance-result/:traceId
```

Response:
```json
{
  "query": "Latest information about AAPL and MSFT",
  "timestamp": "2023-06-15T12:34:56.789Z",
  "response": {
    "summary": "Results for \"Latest information about AAPL and MSFT\"",
    "webResources": [...],
    "financialData": [...],
    "aiAnalysis": {...}
  },
  "status": "success"
}
```

## 🏃‍♂️ Running the Application

1. Start the development server:
   ```bash
   pnpm dev
   ```

2. Access the Motia Workbench:
   ```
   http://localhost:3000
   ```

3. Make a test request:
   ```bash
   curl -X POST http://localhost:3000/finance-query \
     -H "Content-Type: application/json" \
     -d '{"query": "Latest information about AAPL and MSFT"}'
   ```
## 🙏 Acknowledgments

- [Motia Framework](https://motia.dev) for the event-driven workflow engine
- [Alpha Vantage](https://www.alphavantage.co/) for financial data
- [SerperDev](https://serper.dev/) for web search capabilities
- [OpenAI](https://platform.openai.com/) for AI analysis 

-   [github-integration-workflow](/llm-docs/real-world-use-cases/github-integration-workflow.md): Documentation for github-integration-workflow.
---
title: GitHub Integration Workflow
description: Build an automated GitHub issue and PR management system with AI-powered classification and routing
---

## Let's build a GitHub automation system that:

1. Automatically triages and classifies new issues
2. Intelligently assigns labels based on content
3. Suggests appropriate assignees and reviewers
4. Monitors PR test status
5. Generates contextual comments

## Workflow Structure

The GitHub integration workflow is organized into two main components:

- **Issue Triage**: Handles the management of GitHub issues
- **PR Classifier**: Manages pull request workflows

## The Steps

<Folder name="steps" defaultOpen>
  <Folder name="issue-triage" defaultOpen>
    <File name="github-webhook.step.ts" />
    <File name="issue-classifier.step.ts" />
    <File name="label-assigner.step.ts" />
    <File name="assignee-selector.step.ts" />
    <File name="handle-new-issue.step.ts" />
    <File name="handle-issue-update.step.ts" />
    <File name="handle-issue-closure.step.ts" />
  </Folder>
  <Folder name="pr-classifier" defaultOpen>
    <File name="pr-webhook.step.ts" />
    <File name="pr-classifier.step.ts" />
    <File name="pr-label-assigner.step.ts" />
    <File name="pr-reviewer-assigner.step.ts" />
    <File name="pr-test-monitor.step.ts" />
  </Folder>
</Folder>

<Tabs items={['issue-webhook', 'issue-classifier', 'label-assigner', 'assignee-selector']}>
  <GitHubWorkflowTab tab="issue-webhook" value="github-webhook" folder="issue-triage" />
  <GitHubWorkflowTab tab="issue-classifier" value="issue-classifier" folder="issue-triage" />
  <GitHubWorkflowTab tab="label-assigner" value="label-assigner" folder="issue-triage" />
  <GitHubWorkflowTab tab="assignee-selector" value="assignee-selector" folder="issue-triage" />
</Tabs>

<Tabs items={['pr-webhook', 'pr-classifier', 'pr-reviewer', 'pr-monitor']}>
  <GitHubWorkflowTab tab="pr-webhook" value="pr-webhook" folder="pr-classifier" />
  <GitHubWorkflowTab tab="pr-classifier" value="pr-classifier" folder="pr-classifier" />
  <GitHubWorkflowTab tab="pr-reviewer" value="pr-reviewer-assigner" folder="pr-classifier" />
  <GitHubWorkflowTab tab="pr-monitor" value="pr-test-monitor" folder="pr-classifier" />
</Tabs>

## Visual Overview

Here's how the automation flow works:

<div className="my-8">![Flow: GitHub Issue Workflow](../img/github-issue-workflow.png)</div>
<div className="my-8">![Flow: GitHub PR Workflow](../img/github-pr-workflow.png)</div>

1. **Webhook Reception** → Captures GitHub events
2. **Issue/PR Classification** → Analyzes content with AI
3. **Automated Labeling** → Applies appropriate labels
4. **Smart Assignment** → Suggests reviewers and assignees
5. **Status Monitoring** → Tracks PR test status

## Try It Out

<Steps>

### Prerequisites

Make sure you have:

- GitHub account with personal access token
- Node.js installed
- OpenAI API key (for AI classification)

### Clone the Repository

```bash
git clone git@github.com:MotiaDev/motia-examples.git
cd examples/github-integration-workflow
```

### Install Dependencies

```bash
npm install
```

### Configure Environment Variables

Create a `.env` file by copying the example:

```bash
cp .env.example .env
```

Update your `.env` with the following credentials:

```bash
GITHUB_TOKEN=your_github_token_here
OPENAI_API_KEY=your_openai_api_key
```

### Set Up GitHub Webhook

1. Go to your GitHub repository settings
2. Navigate to Webhooks and add a new webhook
3. Set the Payload URL to your Motia server endpoint
4. Select content type as `application/json`
5. Choose which events to trigger the webhook (Issues, Pull requests)
6. Save the webhook

### Run the Application

```bash
npm run dev
```

### Test the Flow

1. Create a new issue in your GitHub repository
2. Watch as it gets automatically classified and labeled
3. Create a new PR to see the reviewer assignment in action
4. Check the PR comments for test status updates

</Steps>

<Callout type="info">
  For more detailed setup instructions and configuration options, check out the [full
  documentation](https://github.com/MotiaDev/motia-examples/tree/main/examples/github-integration-workflow).
</Callout> 


## Use Cases
[github-integration-workflow](/llm-docs/real-world-use-cases/github-integration-workflow.md): Real world use case
---
title: GitHub Integration Workflow
description: Build an automated GitHub issue and PR management system with AI-powered classification and routing
---

## Let's build a GitHub automation system that:

1. Automatically triages and classifies new issues
2. Intelligently assigns labels based on content
3. Suggests appropriate assignees and reviewers
4. Monitors PR test status
5. Generates contextual comments

## Workflow Structure

The GitHub integration workflow is organized into two main components:

- **Issue Triage**: Handles the management of GitHub issues
- **PR Classifier**: Manages pull request workflows

## The Steps

<Folder name="steps" defaultOpen>
  <Folder name="issue-triage" defaultOpen>
    <File name="github-webhook.step.ts" />
    <File name="issue-classifier.step.ts" />
    <File name="label-assigner.step.ts" />
    <File name="assignee-selector.step.ts" />
    <File name="handle-new-issue.step.ts" />
    <File name="handle-issue-update.step.ts" />
    <File name="handle-issue-closure.step.ts" />
  </Folder>
  <Folder name="pr-classifier" defaultOpen>
    <File name="pr-webhook.step.ts" />
    <File name="pr-classifier.step.ts" />
    <File name="pr-label-assigner.step.ts" />
    <File name="pr-reviewer-assigner.step.ts" />
    <File name="pr-test-monitor.step.ts" />
  </Folder>
</Folder>

<Tabs items={['issue-webhook', 'issue-classifier', 'label-assigner', 'assignee-selector']}>
  <GitHubWorkflowTab tab="issue-webhook" value="github-webhook" folder="issue-triage" />
  <GitHubWorkflowTab tab="issue-classifier" value="issue-classifier" folder="issue-triage" />
  <GitHubWorkflowTab tab="label-assigner" value="label-assigner" folder="issue-triage" />
  <GitHubWorkflowTab tab="assignee-selector" value="assignee-selector" folder="issue-triage" />
</Tabs>

<Tabs items={['pr-webhook', 'pr-classifier', 'pr-reviewer', 'pr-monitor']}>
  <GitHubWorkflowTab tab="pr-webhook" value="pr-webhook" folder="pr-classifier" />
  <GitHubWorkflowTab tab="pr-classifier" value="pr-classifier" folder="pr-classifier" />
  <GitHubWorkflowTab tab="pr-reviewer" value="pr-reviewer-assigner" folder="pr-classifier" />
  <GitHubWorkflowTab tab="pr-monitor" value="pr-test-monitor" folder="pr-classifier" />
</Tabs>

## Visual Overview

Here's how the automation flow works:

<div className="my-8">![Flow: GitHub Issue Workflow](../img/github-issue-workflow.png)</div>
<div className="my-8">![Flow: GitHub PR Workflow](../img/github-pr-workflow.png)</div>

1. **Webhook Reception** → Captures GitHub events
2. **Issue/PR Classification** → Analyzes content with AI
3. **Automated Labeling** → Applies appropriate labels
4. **Smart Assignment** → Suggests reviewers and assignees
5. **Status Monitoring** → Tracks PR test status

## Try It Out

<Steps>

### Prerequisites

Make sure you have:

- GitHub account with personal access token
- Node.js installed
- OpenAI API key (for AI classification)

### Clone the Repository

```bash
git clone git@github.com:MotiaDev/motia-examples.git
cd examples/github-integration-workflow
```

### Install Dependencies

```bash
npm install
```

### Configure Environment Variables

Create a `.env` file by copying the example:

```bash
cp .env.example .env
```

Update your `.env` with the following credentials:

```bash
GITHUB_TOKEN=your_github_token_here
OPENAI_API_KEY=your_openai_api_key
```

### Set Up GitHub Webhook

1. Go to your GitHub repository settings
2. Navigate to Webhooks and add a new webhook
3. Set the Payload URL to your Motia server endpoint
4. Select content type as `application/json`
5. Choose which events to trigger the webhook (Issues, Pull requests)
6. Save the webhook

### Run the Application

```bash
npm run dev
```

### Test the Flow

1. Create a new issue in your GitHub repository
2. Watch as it gets automatically classified and labeled
3. Create a new PR to see the reviewer assignment in action
4. Check the PR comments for test status updates

</Steps>

<Callout type="info">
  For more detailed setup instructions and configuration options, check out the [full
  documentation](https://github.com/MotiaDev/motia-examples/tree/main/examples/github-integration-workflow).
</Callout> 

-   [gmail-automation](/llm-docs/real-world-use-cases/gmail-automation.md): Documentation for gmail-automation.
---
title: Gmail Automation
description: Build an automated email system with smart labeling, auto-responses, and AI-powered filtering
---

import { GmailTab } from '../../../components/GmailCodeFetcher'

## Let's build a Gmail automation system that:

- 📊 Smart email classification by category (work, personal, social, promotion, spam, update)
- 🚨 Urgency detection (high, medium, low) with prioritization
- 💬 Intelligent automated responses based on email context
- 🏷️ Automatic email organization (labeling, archiving)
- 📈 Daily summary reports via Discord
- 🔒 Secure Gmail API integration with OAuth2 authentication flow
- ⚡ Real-time email monitoring with webhook notifications

## The Steps

<Folder name="steps" defaultOpen>
  <File name="analyze-email.step.py" />
  <File name="auto-responder.step.ts" />
  <File name="daily-summary.step.ts" />
  <File name="fetch-email.step.ts" />
  <File name="gmail-webhook.step.ts" />
  <File name="organize-email.step.ts" />
</Folder>

<Tabs items={['webhook', 'analyze-email', 'auto-responder', 'daily-summary', 'fetch-email', 'organize-email']}>
  <GmailTab tab="webhook" value="gmail-webhook" />
  <GmailTab tab="analyze-email" value="analyze-email" fileExtension="py" />
  <GmailTab tab="auto-responder" value="auto-responder" />
  <GmailTab tab="daily-summary" value="daily-summary" />
  <GmailTab tab="fetch-email" value="fetch-email" />
  <GmailTab tab="organize-email" value="organize-email" />
</Tabs>

## Visual Overview

Here's how the automation flow works:

<div className="my-8">![Flow: Gmail Automation Steps](../img/gmail-automation.png)</div>

## 🌊 Workflow Architecture

The Gmail Account Manager workflow consists of the following steps:

### 1. Gmail Authentication (Multi-Step Flow)
- **Files**: 
  - `steps/gmail-get-auth-url.step.ts`: Generates OAuth2 authorization URL
  - `steps/gmail-auth.step.ts`: Handles authorization code exchange
  - `steps/gmail-token-status.step.ts`: Checks token validity and refreshes if needed

### 2. Gmail Webhook (API Step)
- **File**: `steps/gmail-webhook.step.ts`
- **Purpose**: Receives notifications from Gmail when new emails arrive
- **Emits**: `gmail.new_email` event with message details
- **Endpoint**: `POST /api/gmail-webhook`

### 3. Gmail Watch (API Step)
- **File**: `steps/gmail-watch.step.ts`
- **Purpose**: Sets up push notifications for the Gmail account
- **Endpoint**: `GET /api/watch`

### 4. Fetch Email (Event Step)
- **File**: `steps/fetch-email.step.ts`
- **Purpose**: Retrieves the full email content from Gmail API
- **Subscribes to**: `gmail.email.received`
- **Emits**: `gmail.email.fetched` with complete email data
- **Key Functions**: Authenticates with Gmail API, fetches message content, parses attachments

### 5. Analyze Email (Event Step)
- **File**: `steps/analyze-email.step.py`
- **Purpose**: Uses Hugging Face models to analyze email content
- **Subscribes to**: `gmail.email.fetched`
- **Emits**: `gmail.email.analyzed` with analysis results
- **Analysis Performed**: 
  - Category classification
  - Urgency detection
  - Sentiment analysis
  - Key information extraction

### 6. Organize Email (Event Step)
- **File**: `steps/organize-email.step.ts`
- **Purpose**: Applies labels and organization based on analysis
- **Subscribes to**: `gmail.email.analyzed`
- **Emits**: `[gmail.email.organized, gmail.email.archived]`
- **Actions**: Creates/applies labels, archives certain emails, marks importance

### 7. Auto-Respond to Email (Event Step)
- **File**: `steps/auto-responder.step.ts`
- **Purpose**: Generates and sends appropriate responses for certain emails
- **Subscribes to**: `gmail.email.analyzed`
- **Emits**: `gmail.email.responded`
- **Features**: 
  - Template selection based on email context
  - Personalization of responses
  - Auto-reply for urgent messages
  - Follow-up scheduling

### 8. Daily Summary (Cron Step)
- **File**: `steps/daily-summary.step.ts`
- **Purpose**: Compiles and sends daily email activity summary
- **Schedule**: Runs daily at 6:00 PM
- **Emits**: `gmail.summary.sent`
- **Delivery**: Sends report to Discord via webhook

## Try It Out

<Steps>
## 📋 Prerequisites

- **Node.js** (v18+)
- **Python** (v3.8+)
- **Gmail API credentials** (client_id and client_secret)
- **Google Cloud project** with Pub/Sub API enabled
- **Hugging Face API token**
- **Discord webhook URL** (for daily summaries)

## 🚀 Quick Start

1. **Clone this repository**
   ```bash
   git clone https://github.com/yourusername/gmail-flow.git
   cd gmail-flow
   ```

2. **Install Node.js dependencies**
   ```bash
   pnpm install
   ```

3. **Install Python dependencies**
   ```bash
   pip install -r requirements.txt
   ```

4. **Configure environment variables**
   ```bash
   cp .env.example .env
   ```
   Then edit the `.env` file with your credentials (see setup sections below).

5. **Start the development server**
   ```bash
   pnpm dev
   ```

6. **Open the Motia Workbench**
   
   Navigate to [http://localhost:3000](http://localhost:3000) to access the workflow UI.

## 🔧 Detailed Setup

### Setting up Google Cloud Project and Gmail API

Before you can use the Gmail Account Manager, you need to set up a Google Cloud project with the Gmail API and Pub/Sub:

1. **Create a Google Cloud Project**:
   - Go to [Google Cloud Console](https://console.cloud.google.com/)
   - Click on "New Project" and follow the steps to create a new project
   - Note your project ID for later use

2. **Enable the Gmail API**:
   - In your project, go to "APIs & Services" > "Library"
   - Search for "Gmail API" and click on it
   - Click "Enable"

3. **Enable the Pub/Sub API**:
   - In your project, go to "APIs & Services" > "Library"
   - Search for "Cloud Pub/Sub API" and click on it
   - Click "Enable"

4. **Create OAuth Credentials**:
   - Go to "APIs & Services" > "Credentials"
   - Click "Create Credentials" > "OAuth client ID"
   - Set the application type to "Desktop app"
   - Click "Create"
   - Note your Client ID and Client Secret for your `.env` file:
     ```
     GOOGLE_CLIENT_ID=your_client_id
     GOOGLE_CLIENT_SECRET=your_client_secret
     ```

### Setting up Google Pub/Sub for Gmail Notifications

To enable real-time email notifications, you need to set up a Google Cloud Pub/Sub topic and subscription:

1. **Create a Pub/Sub Topic**:
   - In your Google Cloud Console, go to "Pub/Sub" > "Topics"
   - Click "Create Topic"
   - Name your topic (e.g., `gmail-notifications`)
   - Add the service account `gmail-api-push@system.gserviceaccount.com` as a Topic Publisher to allow Gmail to publish notifications
   - Click "Create"
   - Note the full topic name (usually `projects/your-project-id/topics/gmail-notifications`) for your `.env` file:
     ```
     GOOGLE_PUBSUB_TOPIC=projects/your-project-id/topics/gmail-notifications
     ```

2. **Create a Pub/Sub Subscription**:
   - Once your topic is created, click "Create Subscription"
   - Name your subscription (e.g., `gmail-notifications-push`)
   - Set the Delivery Type to "Push"
   - Set the Endpoint URL to your webhook URL (e.g., `https://your-domain.com/api/gmail-webhook`)
     - For local development, you'll need to use a tool like ngrok to expose your local server
   - Click "Create"

3. **Set up Domain Verification** (if needed):
   - If you're using a custom domain for your webhook endpoint, you may need to verify domain ownership
   - Follow the instructions in Google Cloud Console for domain verification

### Gmail API Authentication

This project includes a complete OAuth2 authentication flow for the Gmail API:

1. Start the development server: `pnpm dev`
2. Navigate to the authentication workflow in the Motia Workbench
3. The workflow will generate an authorization URL
4. Open the URL in your browser and authorize the application
5. The application will receive and store your authentication tokens

### Discord Webhook Configuration

To receive daily email summaries in Discord, follow these steps to set up a webhook:

1. **Create a Discord Server** (skip if you already have one):
   - Open Discord and click the "+" icon on the left sidebar
   - Select "Create My Own" and follow the setup wizard

2. **Create a Channel for Notifications**:
   - Right-click on your server name and select "Server Settings"
   - Go to "Channels" and click "Create Channel"
   - Name it (e.g., "email-summaries") and click "Create"

3. **Create a Webhook**:
   - Right-click on your new channel and select "Edit Channel"
   - Go to "Integrations" tab
   - Click "Create Webhook"
   - Give it a name (e.g., "Gmail Summary Bot")
   - Optionally, customize the avatar
   - Click "Copy Webhook URL"

4. **Add Webhook URL to Environment Variables**:
   - Open your `.env` file
   - Add or update the Discord webhook URL:
     ```
     DISCORD_WEBHOOK_URL=https://discord.com/api/webhooks/your-webhook-url
     ```

5. **Test the Webhook**:
   - You can test if your webhook is working correctly with this curl command:
     ```bash
     curl -X POST -H "Content-Type: application/json" \
     -d '{"content": "Testing Gmail Account Manager webhook"}' \
     https://discord.com/api/webhooks/your-webhook-url
     ```
   - You should see the message appear in your Discord channel

### Hugging Face Setup

1. **Create a Hugging Face Account**:
   - Sign up at [Hugging Face](https://huggingface.co/join)

2. **Generate an API Token**:
   - Go to your [Hugging Face account settings](https://huggingface.co/settings/tokens)
   - Create a new API token
   - Copy the token to your `.env` file:
     ```
     HUGGINGFACE_API_TOKEN=your_api_token
     ```

</Steps>

## 📁 Project Structure

- `steps/` - Contains all workflow steps
  - `gmail-get-auth-url.step.ts` - Generates OAuth2 URL
  - `gmail-auth.step.ts` - Handles OAuth2 flow
  - `gmail-token-status.step.ts` - Manages token refresh
  - `gmail-webhook.step.ts` - Webhook endpoint for Gmail notifications
  - `gmail-watch.step.ts` - Sets up Gmail push notifications
  - `fetch-email.step.ts` - Fetches email content from Gmail API
  - `analyze-email.step.py` - Python step for email analysis using Hugging Face
  - `organize-email.step.ts` - Organizes emails (labels, archives)
  - `auto-responder.step.ts` - Generates appropriate responses
  - `daily-summary.step.ts` - Sends daily summary to Discord
- `services/` - Shared service modules
- `config/` - Configuration files
- `.motia/` - Motia framework configuration

## 📦 Dependencies

### Node.js Dependencies
- **@motiadev/core**, **@motiadev/workbench**, **motia**: Motia framework
- **googleapis**, **google-auth-library**: Google API integration
- **gmail-api-parse-message-ts**: Gmail message parsing
- **axios**: HTTP client
- **zod**: Schema validation
- **react**: UI components

### Python Dependencies
- **transformers**, **torch**: Machine learning models
- **scikit-learn**, **numpy**, **pandas**: Data processing
- **huggingface_hub**: Access to Hugging Face models
- **python-dotenv**: Environment variable loading

## 🛠️ Troubleshooting

- **Python Module Errors**: Ensure you've installed all required Python packages with `pip install -r requirements.txt`
- **Authentication Errors**: Verify your API credentials and follow the authentication flow
- **Webhook Issues**: Make sure the webhook endpoint is publicly accessible or properly configured for testing
- **Token Refresh Errors**: Check that your OAuth tokens are valid and that the refresh flow is working properly
- **Pub/Sub Not Working**: Verify that your Pub/Sub topic and subscription are properly configured and that your service account has the necessary permissions

## 📝 Environment Variables

Create a `.env` file with the following variables:

```
# Google API Configuration
GOOGLE_CLIENT_ID=your_client_id
GOOGLE_CLIENT_SECRET=your_client_secret
GOOGLE_PUBSUB_TOPIC=projects/your-project-id/topics/gmail-notifications

# HuggingFace Configuration
HUGGINGFACE_API_TOKEN=your_huggingface_token

# Discord Integration
DISCORD_WEBHOOK_URL=https://discord.com/api/webhooks/your-webhook-url

# Auto-Responder Configuration
AUTO_RESPONDER_NAME=Your Name
AUTO_RESPONDER_EMAIL=your-email@example.com
```



## Use Cases
[gmail-automation](/llm-docs/real-world-use-cases/gmail-automation.md): Real world use case
---
title: Gmail Automation
description: Build an automated email system with smart labeling, auto-responses, and AI-powered filtering
---

import { GmailTab } from '../../../components/GmailCodeFetcher'

## Let's build a Gmail automation system that:

- 📊 Smart email classification by category (work, personal, social, promotion, spam, update)
- 🚨 Urgency detection (high, medium, low) with prioritization
- 💬 Intelligent automated responses based on email context
- 🏷️ Automatic email organization (labeling, archiving)
- 📈 Daily summary reports via Discord
- 🔒 Secure Gmail API integration with OAuth2 authentication flow
- ⚡ Real-time email monitoring with webhook notifications

## The Steps

<Folder name="steps" defaultOpen>
  <File name="analyze-email.step.py" />
  <File name="auto-responder.step.ts" />
  <File name="daily-summary.step.ts" />
  <File name="fetch-email.step.ts" />
  <File name="gmail-webhook.step.ts" />
  <File name="organize-email.step.ts" />
</Folder>

<Tabs items={['webhook', 'analyze-email', 'auto-responder', 'daily-summary', 'fetch-email', 'organize-email']}>
  <GmailTab tab="webhook" value="gmail-webhook" />
  <GmailTab tab="analyze-email" value="analyze-email" fileExtension="py" />
  <GmailTab tab="auto-responder" value="auto-responder" />
  <GmailTab tab="daily-summary" value="daily-summary" />
  <GmailTab tab="fetch-email" value="fetch-email" />
  <GmailTab tab="organize-email" value="organize-email" />
</Tabs>

## Visual Overview

Here's how the automation flow works:

<div className="my-8">![Flow: Gmail Automation Steps](../img/gmail-automation.png)</div>

## 🌊 Workflow Architecture

The Gmail Account Manager workflow consists of the following steps:

### 1. Gmail Authentication (Multi-Step Flow)
- **Files**: 
  - `steps/gmail-get-auth-url.step.ts`: Generates OAuth2 authorization URL
  - `steps/gmail-auth.step.ts`: Handles authorization code exchange
  - `steps/gmail-token-status.step.ts`: Checks token validity and refreshes if needed

### 2. Gmail Webhook (API Step)
- **File**: `steps/gmail-webhook.step.ts`
- **Purpose**: Receives notifications from Gmail when new emails arrive
- **Emits**: `gmail.new_email` event with message details
- **Endpoint**: `POST /api/gmail-webhook`

### 3. Gmail Watch (API Step)
- **File**: `steps/gmail-watch.step.ts`
- **Purpose**: Sets up push notifications for the Gmail account
- **Endpoint**: `GET /api/watch`

### 4. Fetch Email (Event Step)
- **File**: `steps/fetch-email.step.ts`
- **Purpose**: Retrieves the full email content from Gmail API
- **Subscribes to**: `gmail.email.received`
- **Emits**: `gmail.email.fetched` with complete email data
- **Key Functions**: Authenticates with Gmail API, fetches message content, parses attachments

### 5. Analyze Email (Event Step)
- **File**: `steps/analyze-email.step.py`
- **Purpose**: Uses Hugging Face models to analyze email content
- **Subscribes to**: `gmail.email.fetched`
- **Emits**: `gmail.email.analyzed` with analysis results
- **Analysis Performed**: 
  - Category classification
  - Urgency detection
  - Sentiment analysis
  - Key information extraction

### 6. Organize Email (Event Step)
- **File**: `steps/organize-email.step.ts`
- **Purpose**: Applies labels and organization based on analysis
- **Subscribes to**: `gmail.email.analyzed`
- **Emits**: `[gmail.email.organized, gmail.email.archived]`
- **Actions**: Creates/applies labels, archives certain emails, marks importance

### 7. Auto-Respond to Email (Event Step)
- **File**: `steps/auto-responder.step.ts`
- **Purpose**: Generates and sends appropriate responses for certain emails
- **Subscribes to**: `gmail.email.analyzed`
- **Emits**: `gmail.email.responded`
- **Features**: 
  - Template selection based on email context
  - Personalization of responses
  - Auto-reply for urgent messages
  - Follow-up scheduling

### 8. Daily Summary (Cron Step)
- **File**: `steps/daily-summary.step.ts`
- **Purpose**: Compiles and sends daily email activity summary
- **Schedule**: Runs daily at 6:00 PM
- **Emits**: `gmail.summary.sent`
- **Delivery**: Sends report to Discord via webhook

## Try It Out

<Steps>
## 📋 Prerequisites

- **Node.js** (v18+)
- **Python** (v3.8+)
- **Gmail API credentials** (client_id and client_secret)
- **Google Cloud project** with Pub/Sub API enabled
- **Hugging Face API token**
- **Discord webhook URL** (for daily summaries)

## 🚀 Quick Start

1. **Clone this repository**
   ```bash
   git clone https://github.com/yourusername/gmail-flow.git
   cd gmail-flow
   ```

2. **Install Node.js dependencies**
   ```bash
   pnpm install
   ```

3. **Install Python dependencies**
   ```bash
   pip install -r requirements.txt
   ```

4. **Configure environment variables**
   ```bash
   cp .env.example .env
   ```
   Then edit the `.env` file with your credentials (see setup sections below).

5. **Start the development server**
   ```bash
   pnpm dev
   ```

6. **Open the Motia Workbench**
   
   Navigate to [http://localhost:3000](http://localhost:3000) to access the workflow UI.

## 🔧 Detailed Setup

### Setting up Google Cloud Project and Gmail API

Before you can use the Gmail Account Manager, you need to set up a Google Cloud project with the Gmail API and Pub/Sub:

1. **Create a Google Cloud Project**:
   - Go to [Google Cloud Console](https://console.cloud.google.com/)
   - Click on "New Project" and follow the steps to create a new project
   - Note your project ID for later use

2. **Enable the Gmail API**:
   - In your project, go to "APIs & Services" > "Library"
   - Search for "Gmail API" and click on it
   - Click "Enable"

3. **Enable the Pub/Sub API**:
   - In your project, go to "APIs & Services" > "Library"
   - Search for "Cloud Pub/Sub API" and click on it
   - Click "Enable"

4. **Create OAuth Credentials**:
   - Go to "APIs & Services" > "Credentials"
   - Click "Create Credentials" > "OAuth client ID"
   - Set the application type to "Desktop app"
   - Click "Create"
   - Note your Client ID and Client Secret for your `.env` file:
     ```
     GOOGLE_CLIENT_ID=your_client_id
     GOOGLE_CLIENT_SECRET=your_client_secret
     ```

### Setting up Google Pub/Sub for Gmail Notifications

To enable real-time email notifications, you need to set up a Google Cloud Pub/Sub topic and subscription:

1. **Create a Pub/Sub Topic**:
   - In your Google Cloud Console, go to "Pub/Sub" > "Topics"
   - Click "Create Topic"
   - Name your topic (e.g., `gmail-notifications`)
   - Add the service account `gmail-api-push@system.gserviceaccount.com` as a Topic Publisher to allow Gmail to publish notifications
   - Click "Create"
   - Note the full topic name (usually `projects/your-project-id/topics/gmail-notifications`) for your `.env` file:
     ```
     GOOGLE_PUBSUB_TOPIC=projects/your-project-id/topics/gmail-notifications
     ```

2. **Create a Pub/Sub Subscription**:
   - Once your topic is created, click "Create Subscription"
   - Name your subscription (e.g., `gmail-notifications-push`)
   - Set the Delivery Type to "Push"
   - Set the Endpoint URL to your webhook URL (e.g., `https://your-domain.com/api/gmail-webhook`)
     - For local development, you'll need to use a tool like ngrok to expose your local server
   - Click "Create"

3. **Set up Domain Verification** (if needed):
   - If you're using a custom domain for your webhook endpoint, you may need to verify domain ownership
   - Follow the instructions in Google Cloud Console for domain verification

### Gmail API Authentication

This project includes a complete OAuth2 authentication flow for the Gmail API:

1. Start the development server: `pnpm dev`
2. Navigate to the authentication workflow in the Motia Workbench
3. The workflow will generate an authorization URL
4. Open the URL in your browser and authorize the application
5. The application will receive and store your authentication tokens

### Discord Webhook Configuration

To receive daily email summaries in Discord, follow these steps to set up a webhook:

1. **Create a Discord Server** (skip if you already have one):
   - Open Discord and click the "+" icon on the left sidebar
   - Select "Create My Own" and follow the setup wizard

2. **Create a Channel for Notifications**:
   - Right-click on your server name and select "Server Settings"
   - Go to "Channels" and click "Create Channel"
   - Name it (e.g., "email-summaries") and click "Create"

3. **Create a Webhook**:
   - Right-click on your new channel and select "Edit Channel"
   - Go to "Integrations" tab
   - Click "Create Webhook"
   - Give it a name (e.g., "Gmail Summary Bot")
   - Optionally, customize the avatar
   - Click "Copy Webhook URL"

4. **Add Webhook URL to Environment Variables**:
   - Open your `.env` file
   - Add or update the Discord webhook URL:
     ```
     DISCORD_WEBHOOK_URL=https://discord.com/api/webhooks/your-webhook-url
     ```

5. **Test the Webhook**:
   - You can test if your webhook is working correctly with this curl command:
     ```bash
     curl -X POST -H "Content-Type: application/json" \
     -d '{"content": "Testing Gmail Account Manager webhook"}' \
     https://discord.com/api/webhooks/your-webhook-url
     ```
   - You should see the message appear in your Discord channel

### Hugging Face Setup

1. **Create a Hugging Face Account**:
   - Sign up at [Hugging Face](https://huggingface.co/join)

2. **Generate an API Token**:
   - Go to your [Hugging Face account settings](https://huggingface.co/settings/tokens)
   - Create a new API token
   - Copy the token to your `.env` file:
     ```
     HUGGINGFACE_API_TOKEN=your_api_token
     ```

</Steps>

## 📁 Project Structure

- `steps/` - Contains all workflow steps
  - `gmail-get-auth-url.step.ts` - Generates OAuth2 URL
  - `gmail-auth.step.ts` - Handles OAuth2 flow
  - `gmail-token-status.step.ts` - Manages token refresh
  - `gmail-webhook.step.ts` - Webhook endpoint for Gmail notifications
  - `gmail-watch.step.ts` - Sets up Gmail push notifications
  - `fetch-email.step.ts` - Fetches email content from Gmail API
  - `analyze-email.step.py` - Python step for email analysis using Hugging Face
  - `organize-email.step.ts` - Organizes emails (labels, archives)
  - `auto-responder.step.ts` - Generates appropriate responses
  - `daily-summary.step.ts` - Sends daily summary to Discord
- `services/` - Shared service modules
- `config/` - Configuration files
- `.motia/` - Motia framework configuration

## 📦 Dependencies

### Node.js Dependencies
- **@motiadev/core**, **@motiadev/workbench**, **motia**: Motia framework
- **googleapis**, **google-auth-library**: Google API integration
- **gmail-api-parse-message-ts**: Gmail message parsing
- **axios**: HTTP client
- **zod**: Schema validation
- **react**: UI components

### Python Dependencies
- **transformers**, **torch**: Machine learning models
- **scikit-learn**, **numpy**, **pandas**: Data processing
- **huggingface_hub**: Access to Hugging Face models
- **python-dotenv**: Environment variable loading

## 🛠️ Troubleshooting

- **Python Module Errors**: Ensure you've installed all required Python packages with `pip install -r requirements.txt`
- **Authentication Errors**: Verify your API credentials and follow the authentication flow
- **Webhook Issues**: Make sure the webhook endpoint is publicly accessible or properly configured for testing
- **Token Refresh Errors**: Check that your OAuth tokens are valid and that the refresh flow is working properly
- **Pub/Sub Not Working**: Verify that your Pub/Sub topic and subscription are properly configured and that your service account has the necessary permissions

## 📝 Environment Variables

Create a `.env` file with the following variables:

```
# Google API Configuration
GOOGLE_CLIENT_ID=your_client_id
GOOGLE_CLIENT_SECRET=your_client_secret
GOOGLE_PUBSUB_TOPIC=projects/your-project-id/topics/gmail-notifications

# HuggingFace Configuration
HUGGINGFACE_API_TOKEN=your_huggingface_token

# Discord Integration
DISCORD_WEBHOOK_URL=https://discord.com/api/webhooks/your-webhook-url

# Auto-Responder Configuration
AUTO_RESPONDER_NAME=Your Name
AUTO_RESPONDER_EMAIL=your-email@example.com
```


-   [index](/llm-docs/real-world-use-cases/index.md): Documentation for index.
---
title: Real-World Use Cases
description: See how Motia is used to solve real problems
---

# Real-World Use Cases

Explore these practical examples of Motia in action:

- [Trello Card Automation](./real-world-use-cases/trello-automation) - Build an automated card progression system for Trello boards with AI-powered summaries
- [Gmail Automation](./real-world-use-cases/gmail-automation) - Build an automated email system with smart labeling, auto-responses, and AI-powered filtering
- [GitHub Integration Workflow](./real-world-use-cases/github-integration-workflow) - Build an automated GitHub issue and PR management system with AI-powered classification and routing
- [Finance Agent](./real-world-use-cases/finance-agent) - A powerful event-driven financial analysis workflow that combines web search, financial data, and AI analysis
- [AI Deep Research Agent](./real-world-use-cases/ai-deep-research-agent) - A powerful research assistant that leverages the Motia Framework to perform comprehensive web research
- [RAG Agent with Docling & Weaviate](./real-world-use-cases/rag-docling-weaviate-agent) - An LLM chat-like question-answering system with RAG for accurate answers from PDF documents

Have a great use case to share? [Contribute it here](https://github.com/MotiaDev/motia-examples/tree/main/examples). 


## Use Cases
[index](/llm-docs/real-world-use-cases/index.md): Real world use case
---
title: Real-World Use Cases
description: See how Motia is used to solve real problems
---

# Real-World Use Cases

Explore these practical examples of Motia in action:

- [Trello Card Automation](./real-world-use-cases/trello-automation) - Build an automated card progression system for Trello boards with AI-powered summaries
- [Gmail Automation](./real-world-use-cases/gmail-automation) - Build an automated email system with smart labeling, auto-responses, and AI-powered filtering
- [GitHub Integration Workflow](./real-world-use-cases/github-integration-workflow) - Build an automated GitHub issue and PR management system with AI-powered classification and routing
- [Finance Agent](./real-world-use-cases/finance-agent) - A powerful event-driven financial analysis workflow that combines web search, financial data, and AI analysis
- [AI Deep Research Agent](./real-world-use-cases/ai-deep-research-agent) - A powerful research assistant that leverages the Motia Framework to perform comprehensive web research
- [RAG Agent with Docling & Weaviate](./real-world-use-cases/rag-docling-weaviate-agent) - An LLM chat-like question-answering system with RAG for accurate answers from PDF documents

Have a great use case to share? [Contribute it here](https://github.com/MotiaDev/motia-examples/tree/main/examples). 

-   [rag-docling-weaviate-agent](/llm-docs/real-world-use-cases/rag-docling-weaviate-agent.md): Documentation for rag-docling-weaviate-agent.
---
title: RAG Agent using Docling and Weaviate
description: An LLM chat-like question-answering system with RAG (Retrieval-Augmented Generation) to provide accurate answers from PDF documents. The system leverages Docling to parse and intelligently chunk PDF documents, Weaviate as a vector database to store vectorized chunks, and OpenAI for embeddings and text generation.
---

import { CodeFetcher } from '../../../components/CodeFetcher'

## Let's build a PDF RAG Agent with:

- **PDF Document Processing**: Efficiently parses and chunks PDF documents for analysis.
- **Vector Storage with Weaviate**: Stores and manages vectorized document chunks.
- **Docling for Advanced Parsing**: Utilizes Docling for intelligent PDF parsing and hybrid chunking.
- **OpenAI Integration**: Leverages OpenAI for creating embeddings and generating text.
- **RAG Pattern for Q&A**: Implements Retrieval-Augmented Generation for accurate question answering.

## The Steps

<Folder name="steps" defaultOpen>
  <File name="api-process-pdfs.step.ts" />
  <File name="api-query-rag.step.ts" />
  <File name="init-weaviate.step.ts" />
  <File name="load-weaviate.step.ts" />
  <File name="process-pdfs.step.py" />
</Folder>

<Tabs items={['api-process-pdfs', 'api-query-rag', 'init-weaviate', 'load-weaviate', 'process-pdfs']}>
  <CodeFetcher path="examples/rag-docling-weaviate-agent/steps/api-steps" tab="api-process-pdfs" value="api-process-pdfs" />
  <CodeFetcher path="examples/rag-docling-weaviate-agent/steps/api-steps" tab="api-query-rag" value="api-query-rag" />
  <CodeFetcher path="examples/rag-docling-weaviate-agent/steps/event-steps" tab="init-weaviate" value="init-weaviate" />
  <CodeFetcher path="examples/rag-docling-weaviate-agent/steps/event-steps" tab="load-weaviate" value="load-weaviate" />
  <CodeFetcher path="examples/rag-docling-weaviate-agent/steps/event-steps" tab="process-pdfs" value="process-pdfs" fileExtension="py" />
</Tabs>

## 🚀 Features

- **PDF document processing and chunking**: Efficiently parse and chunk PDF documents.
- **Vector storage using Weaviate**: Store and manage vectorized document chunks.
- **Docling for PDF parsing and hybrid chunking**: Uses Docling for advanced document chunking.
- **OpenAI integration for embeddings and text generation**: Leverage OpenAI for creating embeddings and generating text.
- **Question answering using RAG pattern**: Retrieval-Augmented Generation for accurate question answering.

## 📋 Prerequisites

- Node.js v18 or later
- npm or pnpm
- API keys for:
  - [OpenAI](https://platform.openai.com/) (Embeddings and text generation)
  - [Weaviate](https://weaviate.io/) (Vector database)

## 🛠️ Installation

1. Clone the repository:
   ```bash
   git clone https://github.com/MotiaDev/motia-examples
   cd examples/rag-docling-weaviate-agent
   ```

2. Install dependencies:
   ```bash
   pnpm install
   # or
   npm install
   ```

3. Configure environment variables:
   ```bash
   cp .env.example .env
   ```

   Update `.env` with your API keys:
   ```bash
   # Required
   OPENAI_API_KEY=your-openai-api-key-here
   WEAVIATE_API_KEY=your-weaviate-api-key-here
   WEAVIATE_URL=your-weaviate-url-here
   ```

## 🏗️ Architecture

![RAG Docling Weaviate Agent](../img/rag-docling-weaviate-workbench.png)

## 🏗️ Technologies

- **TypeScript**
- **Python**
- **Docling**
- **Weaviate**
- **OpenAI**

## 🚦 API Endpoints

### Process PDFs

```
POST /api/rag/process-pdfs
Content-Type: application/json

{
  "folderPath": "path/to/pdf/folder"
}
```

Response:
```json
{
  "message": "PDF processing workflow started",
  "folderPath": "path/to/pdf/folder"
}
```

### Query RAG System

```
POST /api/rag/query
Content-Type: application/json

{
  "query": "Your question about the PDF content",
  "limit": 5  // Optional, defaults to 5
}
```

Response:
```json
{
  "query": "Your question about the PDF content",
  "answer": "Generated answer based on the PDF content",
  "chunks": [
    {
      "text": "Relevant text chunk from the document",
      "title": "Document title",
      "metadata": {
        "source": "Document source",
        "page": 1
      }
    }
    // ... additional chunks up to the specified limit
  ]
}
```

Error Response:
```json
{
  "error": "Failed to process RAG query",
  "message": "Error details"
}
```

## 🏃‍♂️ Running the Application

1. Start the development server:
   ```bash
   pnpm dev
   ```

2. Access the Motia Workbench:
   ```
   http://localhost:3000
   ```

3. Make test requests:
   ```bash
   # Process PDFs
   curl --request POST \
   --url http://localhost:3000/api/rag/process-pdfs \
   --header 'Content-Type: application/json' \
   --data '{
      "folderPath": "path/to/pdf/folder"
   }'

   # Query the RAG system
   curl --request POST \
   --url http://localhost:3000/api/rag/query \
   --header 'Content-Type: application/json' \
   --data '{
      "query": "Your question about the PDF content",
      "limit": 5
   }'
   ```
## 🙏 Acknowledgments

- [Motia Framework](https://motia.dev) for the event-driven workflow engine
- [Docling](https://github.com/MotiaDev/docling) for PDF parsing and hybrid chunking
- [Weaviate](https://www.weaviate.io/) for Vector Database
- [OpenAI](https://platform.openai.com/) for AI analysis 



## Use Cases
[rag-docling-weaviate-agent](/llm-docs/real-world-use-cases/rag-docling-weaviate-agent.md): Real world use case
---
title: RAG Agent using Docling and Weaviate
description: An LLM chat-like question-answering system with RAG (Retrieval-Augmented Generation) to provide accurate answers from PDF documents. The system leverages Docling to parse and intelligently chunk PDF documents, Weaviate as a vector database to store vectorized chunks, and OpenAI for embeddings and text generation.
---

import { CodeFetcher } from '../../../components/CodeFetcher'

## Let's build a PDF RAG Agent with:

- **PDF Document Processing**: Efficiently parses and chunks PDF documents for analysis.
- **Vector Storage with Weaviate**: Stores and manages vectorized document chunks.
- **Docling for Advanced Parsing**: Utilizes Docling for intelligent PDF parsing and hybrid chunking.
- **OpenAI Integration**: Leverages OpenAI for creating embeddings and generating text.
- **RAG Pattern for Q&A**: Implements Retrieval-Augmented Generation for accurate question answering.

## The Steps

<Folder name="steps" defaultOpen>
  <File name="api-process-pdfs.step.ts" />
  <File name="api-query-rag.step.ts" />
  <File name="init-weaviate.step.ts" />
  <File name="load-weaviate.step.ts" />
  <File name="process-pdfs.step.py" />
</Folder>

<Tabs items={['api-process-pdfs', 'api-query-rag', 'init-weaviate', 'load-weaviate', 'process-pdfs']}>
  <CodeFetcher path="examples/rag-docling-weaviate-agent/steps/api-steps" tab="api-process-pdfs" value="api-process-pdfs" />
  <CodeFetcher path="examples/rag-docling-weaviate-agent/steps/api-steps" tab="api-query-rag" value="api-query-rag" />
  <CodeFetcher path="examples/rag-docling-weaviate-agent/steps/event-steps" tab="init-weaviate" value="init-weaviate" />
  <CodeFetcher path="examples/rag-docling-weaviate-agent/steps/event-steps" tab="load-weaviate" value="load-weaviate" />
  <CodeFetcher path="examples/rag-docling-weaviate-agent/steps/event-steps" tab="process-pdfs" value="process-pdfs" fileExtension="py" />
</Tabs>

## 🚀 Features

- **PDF document processing and chunking**: Efficiently parse and chunk PDF documents.
- **Vector storage using Weaviate**: Store and manage vectorized document chunks.
- **Docling for PDF parsing and hybrid chunking**: Uses Docling for advanced document chunking.
- **OpenAI integration for embeddings and text generation**: Leverage OpenAI for creating embeddings and generating text.
- **Question answering using RAG pattern**: Retrieval-Augmented Generation for accurate question answering.

## 📋 Prerequisites

- Node.js v18 or later
- npm or pnpm
- API keys for:
  - [OpenAI](https://platform.openai.com/) (Embeddings and text generation)
  - [Weaviate](https://weaviate.io/) (Vector database)

## 🛠️ Installation

1. Clone the repository:
   ```bash
   git clone https://github.com/MotiaDev/motia-examples
   cd examples/rag-docling-weaviate-agent
   ```

2. Install dependencies:
   ```bash
   pnpm install
   # or
   npm install
   ```

3. Configure environment variables:
   ```bash
   cp .env.example .env
   ```

   Update `.env` with your API keys:
   ```bash
   # Required
   OPENAI_API_KEY=your-openai-api-key-here
   WEAVIATE_API_KEY=your-weaviate-api-key-here
   WEAVIATE_URL=your-weaviate-url-here
   ```

## 🏗️ Architecture

![RAG Docling Weaviate Agent](../img/rag-docling-weaviate-workbench.png)

## 🏗️ Technologies

- **TypeScript**
- **Python**
- **Docling**
- **Weaviate**
- **OpenAI**

## 🚦 API Endpoints

### Process PDFs

```
POST /api/rag/process-pdfs
Content-Type: application/json

{
  "folderPath": "path/to/pdf/folder"
}
```

Response:
```json
{
  "message": "PDF processing workflow started",
  "folderPath": "path/to/pdf/folder"
}
```

### Query RAG System

```
POST /api/rag/query
Content-Type: application/json

{
  "query": "Your question about the PDF content",
  "limit": 5  // Optional, defaults to 5
}
```

Response:
```json
{
  "query": "Your question about the PDF content",
  "answer": "Generated answer based on the PDF content",
  "chunks": [
    {
      "text": "Relevant text chunk from the document",
      "title": "Document title",
      "metadata": {
        "source": "Document source",
        "page": 1
      }
    }
    // ... additional chunks up to the specified limit
  ]
}
```

Error Response:
```json
{
  "error": "Failed to process RAG query",
  "message": "Error details"
}
```

## 🏃‍♂️ Running the Application

1. Start the development server:
   ```bash
   pnpm dev
   ```

2. Access the Motia Workbench:
   ```
   http://localhost:3000
   ```

3. Make test requests:
   ```bash
   # Process PDFs
   curl --request POST \
   --url http://localhost:3000/api/rag/process-pdfs \
   --header 'Content-Type: application/json' \
   --data '{
      "folderPath": "path/to/pdf/folder"
   }'

   # Query the RAG system
   curl --request POST \
   --url http://localhost:3000/api/rag/query \
   --header 'Content-Type: application/json' \
   --data '{
      "query": "Your question about the PDF content",
      "limit": 5
   }'
   ```
## 🙏 Acknowledgments

- [Motia Framework](https://motia.dev) for the event-driven workflow engine
- [Docling](https://github.com/MotiaDev/docling) for PDF parsing and hybrid chunking
- [Weaviate](https://www.weaviate.io/) for Vector Database
- [OpenAI](https://platform.openai.com/) for AI analysis 


-   [trello-automation](/llm-docs/real-world-use-cases/trello-automation.md): Documentation for trello-automation.
---
title: Trello Card Automation
description: Build an automated card progression system for Trello boards with AI-powered summaries
---

import { TrelloTab, TrelloCodeContent } from '../../../components/TrelloCodeFetcher'

## Let's build a Trello automation system that:

1. Automatically progresses cards across board lists
2. Validates card completeness
3. Generates AI-powered summaries for code review
4. Integrates with Slack for notifications
5. Monitors due dates and sends overdue alerts

## Board Structure

The Trello board is organized into four main lists:

- **New Cards**: Entry point for all new cards
- **In Progress**: Active development stage
- **Needs Review**: Code review stage with AI summaries
- **Completed**: Successfully reviewed and approved cards

## The Steps

<Folder name="steps" defaultOpen>
  <File name="trello-webhook.step.ts" />
  <File name="trello-webhook-validation.step.ts" />
  <File name="validate-card-requirements.step.ts" />
  <File name="start-assigned-card.step.ts" />
  <File name="mark-card-for-review.step.ts" />
  <File name="complete-approved-card.step.ts" />
  <File name="check-overdue-cards.step.ts" />
  <File name="slack-notifier.step.ts" />
</Folder>

<Tabs items={['webhook', 'validation', 'requirements', 'assigned', 'review', 'completion', 'overdue', 'slack']}>
  <TrelloTab tab="webhook" value="trello-webhook" />
  <TrelloTab tab="validation" value="trello-webhook-validation" />
  <TrelloTab tab="requirements" value="validate-card-requirements" />
  <TrelloTab tab="assigned" value="start-assigned-card" />
  <TrelloTab tab="review" value="mark-card-for-review" />
  <TrelloTab tab="completion" value="complete-approved-card" />
  <TrelloTab tab="overdue" value="check-overdue-cards" />
  <TrelloTab tab="slack" value="slack-notifier" />
</Tabs>

## Visual Overview

Here's how the automation flow works:

<div className="my-8">![Flow: Trello Automation Steps](../img/trello-automation.png)</div>

1. **Card Validation** → Checks for required information
2. **Progress Tracking** → Moves cards between lists
3. **Review Process** → Generates AI summaries and notifies reviewers
4. **Completion Handling** → Processes approved cards

## Try It Out

<Steps>

### Prerequisites

Make sure you have:

- Trello account with API access
- Node.js installed
- Slack workspace (for notifications)
- OpenAI API key (for AI summaries)

### Clone the Repository

```bash
git clone git@github.com:MotiaDev/motia-examples.git
cd examples/trello-flow
```

### Install Dependencies

```bash
pnpm install
```

### Configure Environment Variables

Create a `.env` file by copying the example:

```bash
cp .env.example .env
```

Update your `.env` with the following credentials:

```bash
TRELLO_API_KEY=your_trello_api_key
TRELLO_TOKEN=your_trello_token

OPENAI_API_KEY=your_openai_api_key
OPENAI_MODEL=your_openai_model

SLACK_WEBHOOK_URL=your_slack_webhook_url

TRELLO_NEW_TASKS_LIST_ID=your_new_tasks_list_id
TRELLO_IN_PROGRESS_LIST_ID=your_in_progress_list_id
TRELLO_NEEDS_REVIEW_LIST_ID=your_needs_review_list_id
TRELLO_COMPLETED_LIST_ID=your_completed_list_id
```

### Set Up Trello Board

1. Create a new Trello board with these lists:

   - New Tasks
   - In Progress
   - Needs Review
   - Completed

2. Add a custom field:
   - Status (dropdown: Todo, In Progress, Done)

### Run the Application

```bash
pnpm dev
```

### Test the Flow

1. Create a new card in the "New Tasks" list
2. Assign a member to see it move to "In Progress"
3. Add an "approved" comment to see it move to "Completed"
4. Check Slack for notifications

</Steps>

<Callout type="info">
  For more detailed setup instructions and configuration options, check out the [full
  documentation](https://github.com/MotiaDev/motia-examples/tree/main/examples/trello-flow).
</Callout>{' '}



## Use Cases
[trello-automation](/llm-docs/real-world-use-cases/trello-automation.md): Real world use case
---
title: Trello Card Automation
description: Build an automated card progression system for Trello boards with AI-powered summaries
---

import { TrelloTab, TrelloCodeContent } from '../../../components/TrelloCodeFetcher'

## Let's build a Trello automation system that:

1. Automatically progresses cards across board lists
2. Validates card completeness
3. Generates AI-powered summaries for code review
4. Integrates with Slack for notifications
5. Monitors due dates and sends overdue alerts

## Board Structure

The Trello board is organized into four main lists:

- **New Cards**: Entry point for all new cards
- **In Progress**: Active development stage
- **Needs Review**: Code review stage with AI summaries
- **Completed**: Successfully reviewed and approved cards

## The Steps

<Folder name="steps" defaultOpen>
  <File name="trello-webhook.step.ts" />
  <File name="trello-webhook-validation.step.ts" />
  <File name="validate-card-requirements.step.ts" />
  <File name="start-assigned-card.step.ts" />
  <File name="mark-card-for-review.step.ts" />
  <File name="complete-approved-card.step.ts" />
  <File name="check-overdue-cards.step.ts" />
  <File name="slack-notifier.step.ts" />
</Folder>

<Tabs items={['webhook', 'validation', 'requirements', 'assigned', 'review', 'completion', 'overdue', 'slack']}>
  <TrelloTab tab="webhook" value="trello-webhook" />
  <TrelloTab tab="validation" value="trello-webhook-validation" />
  <TrelloTab tab="requirements" value="validate-card-requirements" />
  <TrelloTab tab="assigned" value="start-assigned-card" />
  <TrelloTab tab="review" value="mark-card-for-review" />
  <TrelloTab tab="completion" value="complete-approved-card" />
  <TrelloTab tab="overdue" value="check-overdue-cards" />
  <TrelloTab tab="slack" value="slack-notifier" />
</Tabs>

## Visual Overview

Here's how the automation flow works:

<div className="my-8">![Flow: Trello Automation Steps](../img/trello-automation.png)</div>

1. **Card Validation** → Checks for required information
2. **Progress Tracking** → Moves cards between lists
3. **Review Process** → Generates AI summaries and notifies reviewers
4. **Completion Handling** → Processes approved cards

## Try It Out

<Steps>

### Prerequisites

Make sure you have:

- Trello account with API access
- Node.js installed
- Slack workspace (for notifications)
- OpenAI API key (for AI summaries)

### Clone the Repository

```bash
git clone git@github.com:MotiaDev/motia-examples.git
cd examples/trello-flow
```

### Install Dependencies

```bash
pnpm install
```

### Configure Environment Variables

Create a `.env` file by copying the example:

```bash
cp .env.example .env
```

Update your `.env` with the following credentials:

```bash
TRELLO_API_KEY=your_trello_api_key
TRELLO_TOKEN=your_trello_token

OPENAI_API_KEY=your_openai_api_key
OPENAI_MODEL=your_openai_model

SLACK_WEBHOOK_URL=your_slack_webhook_url

TRELLO_NEW_TASKS_LIST_ID=your_new_tasks_list_id
TRELLO_IN_PROGRESS_LIST_ID=your_in_progress_list_id
TRELLO_NEEDS_REVIEW_LIST_ID=your_needs_review_list_id
TRELLO_COMPLETED_LIST_ID=your_completed_list_id
```

### Set Up Trello Board

1. Create a new Trello board with these lists:

   - New Tasks
   - In Progress
   - Needs Review
   - Completed

2. Add a custom field:
   - Status (dropdown: Todo, In Progress, Done)

### Run the Application

```bash
pnpm dev
```

### Test the Flow

1. Create a new card in the "New Tasks" list
2. Assign a member to see it move to "In Progress"
3. Add an "approved" comment to see it move to "Completed"
4. Check Slack for notifications

</Steps>

<Callout type="info">
  For more detailed setup instructions and configuration options, check out the [full
  documentation](https://github.com/MotiaDev/motia-examples/tree/main/examples/trello-flow).
</Callout>{' '}


-   [build-your-first-app](/llm-docs/getting-started/build-your-first-app.mdx.md): Documentation for build-your-first-app.
---
title: TLDR - Motia in 3 Minutes
description: A 3-minute overview of Motia’s core concepts with a business-ready GenAI use case
---

# TLDR - Motia in 3 Minutes

Got 3 minutes? Here’s the scoop on Motia - Unified Backend Framework for APIs, Events and AI Agents that powers event-driven workflows, perfect for Generative AI (GenAI). We’ll spotlight a real-world win: analyzing customer feedback.

## What’s Motia?
Motia builds scalable, observable workflows without infrastructure headaches. Code in JS, TS, or Python, chain it up, and track it live in a visual Workbench.

- **Why It’s Clutch**: No queue setup, instant APIs/scheduling, real-time insights.
- **Who’s It For**: Businesses wanting intelligent workflows without the hassle.

## Core Concepts in a Nutshell

| Concept    | What It Does                                                                                   | TLDR Feedback Example                        |
|------------|------------------------------------------------------------------------------------------------|----------------------------------------------|
| **Steps**  | Logic blocks that catch events, process, and trigger more.                                    | “Extract sentiment,” “Flag issues,” “Notify.”|
| **Flows**  | Step groups with a goal. Your workflow’s playbook.                                            | “Feedback analyzer” flow.                    |
| **Events** | Messages bouncing between steps, hauling data and sparking action.                            | “Feedback in!” or “Issues flagged!”          |
| **Topics** | Event labels. Steps subscribe to nab what they need.                                          | “Catch ‘feedback.in’ and analyze.”           |

### How It Ties Together
Here’s a business-ready GenAI flow—crunching customer feedback:
1. An **API Step** grabs a review (e.g., `POST /feedback`).
2. It fires an **Event** with **Topic** `feedback.in`.
3. An **Event Step** uses an LLM to extract sentiment (e.g., positive/negative), emitting `sentiment.out`.
4. Another **Step** spots critical issues (e.g., “product broke”), emitting `issues.found`.
5. A final **Step** notifies the team via Slack with sentiment and issues.
6. This rolls in a **Flow** called `feedback-analyzer`, tracked in the Workbench.

## Why Businesses Love It
- **Scales Anything**: Links steps into workflows—GenAI or otherwise—with ease.
- **Language Flex**: Mix Python for analysis, TS for notifications—Motia rolls with it.
- **Real-Time Visualization**: Workbench maps your flow live, logs and all, for instant clarity.

## 3-Minute Takeaway
Motia = **Steps** (logic) → **Events** (messages) → **Topics** (routing) → **Flows** (plans). It’s event-driven power made simple, with a dashboard to keep tabs.

<Callout>
Want to build it? Hit the [Quick Start](/docs/getting-started/quick-start) for a 5-minute go. Or dive into [Core Concepts](/docs/getting-started/core-concepts) for the full rundown.
</Callout>

-   [welcome](/llm-docs/welcome.md): Documentation for welcome.
---
title: Welcome to Motia
description: Get started with Motia, a powerful framework for building event-driven workflows
---

# Unified Backend Framework for APIs, Events and AI Agents

Motia is a **code-first framework** designed to empower developers to build robust, scalable, and observable event-driven workflows with unparalleled ease. We handle the infrastructure complexities, so you can focus on your business logic.

## Why Choose Motia?

Motia is built with the developer in mind, offering a unique blend of simplicity and power. Here's why Motia stands out:

- 🚀 **Zero Infrastructure Setup:** Say goodbye to the complexities of message queues and event brokers! Motia handles the underlying infrastructure, allowing you to focus solely on building your workflows.

- 🔌 **Plug-and-Play Steps in Your Language:**  Develop your workflow logic using the languages you love: JavaScript, TypeScript, and Python. Mix and match languages within the same flow for ultimate flexibility.

- 📊 **Built-in Observability:** Gain deep insights into your workflows with real-time logs, traces, and interactive flow visualizations right in the Motia Workbench. Debugging and monitoring have never been easier.

- ⚡ **Out-of-the-Box API & Scheduling:**  Instantly expose your workflows as HTTP endpoints and schedule tasks with cron expressions – no extra configuration needed.

- ✨ **Flexible and Extensible Architecture:**  Motia is designed to be easily extended and customized. Create custom steps, UI components, and adapt the framework to your specific needs.

- 🧑‍💻 **Developer-First Experience:**  From intuitive APIs and a powerful CLI to comprehensive documentation and a visual workbench, Motia prioritizes developer productivity and a smooth, enjoyable development experience.

## Motia Workbench: Your Development Control Center

Motia Workbench is a built-in, browser-based development platform that acts as your central hub for building, testing, and debugging Motia flows. Key features include:

- **Interactive Flow Visualization:**  See your workflows come to life as dynamic diagrams, making it easy to understand complex event flows and step interactions.

- **Real-time Flow Testing:**  Trigger API endpoints and monitor event propagation through your steps, all within the Workbench UI. Inspect data at each stage to ensure your flows are behaving as expected.

- **Live Log Streaming:**  Access detailed, real-time logs directly in the Workbench. Filter and search logs to quickly pinpoint issues and monitor workflow execution.

- **Step-Level Customization:**  Create custom UI components for your steps to enhance visualization and provide context-specific information directly within the flow diagram.

<div className="my-8">
  ![Motia Workbench Interface](./img/workbench-presentation.png)
</div>

## Core Concepts: Building Blocks of Motia

Motia workflows are built using a few core concepts that work together harmoniously:

| Concept    | Description                                                                                                |
| ---------- | ---------------------------------------------------------------------------------------------------------- |
| **Steps**  | Self-contained, reusable units of business logic. Steps subscribe to events, process data, and emit events. |
| **Flows**  | Logical groupings of related steps that together accomplish a specific task or process.                     |
| **Events** | Messages that are emitted by steps and trigger other steps that subscribe to them.                          |
| **Topics** | Named channels or categories for events, enabling event routing and decoupling between steps.              |

## Unlock Powerful Use Cases

Motia empowers you to build a wide range of sophisticated applications, including:

- 🌐 **API Integrations & Microservices:**  Effortlessly connect disparate systems, create event-driven microservices, and build real-time API-powered applications.

- 🤖 **Intelligent & Agentic Workflows:**  Design complex, AI-driven workflows, orchestrate intricate business processes, and build advanced data pipelines.

- 📊 **Data Transformation & Processing:**  Build scalable ETL/ELT pipelines, implement real-time data streaming, and transform data with ease.

- 🚀 **Rapid Prototyping & Iteration:**  Quickly bring your ideas to life, test new workflows, and iterate rapidly with Motia's visual design and development tools.

### Real-World Industry Applications

Motia is versatile and can be applied across various industries and use cases, such as:

- **E-commerce:** Order processing, inventory synchronization, fraud detection, customer communication automation.
- **Finance:** Trade settlement, risk analysis, compliance monitoring, automated reporting.
- **Healthcare:** Clinical trial management, claims processing, patient monitoring, appointment scheduling.
- **Marketing:** Lead scoring, personalized campaign orchestration, sentiment analysis, social media automation.
- **And much more!**

## Ready to Get Started?

Embark on your Motia journey and start building powerful workflows today:

1.  **Quick Start Guide:** Follow our [Quick Start](/docs/getting-started/quick-start) to set up your first Motia project and create a minimal workflow.
2.  **Explore Examples:** Dive into practical [Examples](/docs/examples) to understand common patterns and real-world use cases.
3.  **Dive into Concepts:**  Delve deeper into Motia's [Core Concepts](/docs/concepts) to gain a solid understanding of the framework's architecture and principles.

## Join the Motia Community

Become part of a growing community of developers and automation enthusiasts!

- 💬 **Join our Discord:**  Connect with the Motia team and fellow developers, ask questions, share ideas, and get real-time help: [Discord Community](https://discord.gg/nJFfsH5d6v)
- 🐙 **Star us on GitHub:** Show your support, contribute to the project, and report issues on our [GitHub Repository](https://github.com/motiadev/motia).
- 🐦 **Follow us on Twitter:** Stay up-to-date with the latest news, announcements, and community updates: [Twitter (@motiadev)](https://twitter.com/motiadev)

We're excited to see what you'll build with Motia!

-   [NOOP Steps](/llm-docs/workbench/noop-steps.md): Documentation for NOOP Steps.
---
title: NOOP Steps
---

NOOP (No Operation) steps are a powerful feature in Motia that serve multiple purposes:

1. Modeling external processes, webhooks and integrations
2. Representing human-in-the-loop activities
3. Creating custom visualizations in the workbench
4. Testing flows during development

## File Structure

NOOP steps require two files with the same base name:
- `stepName.step.ts` - Contains the step configuration
- `stepName.step.tsx` - Contains the UI component (optional)

### Step Configuration File (.ts)

<Tabs items={['TS', 'JS']}>
  <Tab value="TS">
    ```typescript
    // myStep.step.ts
    import { NoopConfig } from 'motia'

    export const config: NoopConfig = {
      type: 'noop',
      name: 'My NOOP Step',
      description: 'Description of what this step simulates',
      virtualEmits: ['event.one', 'event.two'],
      virtualSubscribes: [], // Required even if empty
      flows: ['my-flow'],
    }
    ```
  </Tab>
  <Tab value="JS">
    ```javascript
    // myStep.step.js
    const config = {
      type: 'noop',
      name: 'My NOOP Step',
      description: 'Description of what this step simulates',
      virtualEmits: ['event.one', 'event.two'],
      virtualSubscribes: [], // Required even if empty
      flows: ['my-flow'],
    }

    module.exports = { config }
    ```
  </Tab>
</Tabs>

### UI Component File (.tsx)

<Tabs items={['TS', 'JS']}>
  <Tab value="TS">
    ```typescript
    // myStep.step.tsx
    import React from 'react'
    import { BaseHandle, Position } from 'motia/workbench'

    export default function MyStep() {
      return (
        <div className="p-4 bg-gray-800 rounded-lg border border-gray-600 text-white">
          <div className="text-sm font-medium">My Step UI</div>
          {/* Your custom UI elements */}
          <BaseHandle type="source" position={Position.Bottom} />
        </div>
      )
    }
    ```
  </Tab>
  <Tab value="JS">
    ```javascript
    // myStep.step.jsx
    import React from 'react'
    import { BaseHandle, Position } from 'motia/workbench'

    export default function MyStep() {
      return (
        <div className="p-4 bg-gray-800 rounded-lg border border-gray-600 text-white">
          <div className="text-sm font-medium">My Step UI</div>
          {/* Your custom UI elements */}
          <BaseHandle type="source" position={Position.Bottom} />
        </div>
      )
    }
    ```
  </Tab>
</Tabs>

## Example: Webhook Testing

Here's a complete example of a NOOP step that simulates webhook events:

<Tabs items={['TS', 'JS']}>
  <Tab value="TS">
    ```typescript
    // test-webhook.step.ts
    import { NoopConfig } from 'motia'

    export const config: NoopConfig = {
      type: 'noop',
      name: 'Webhook Simulator',
      description: 'Simulates incoming webhook events',
      virtualEmits: ['webhook.received'],
      virtualSubscribes: [],
      flows: ['webhook-flow'],
    }
    ```
  </Tab>
  <Tab value="JS">
    ```javascript
    // test-webhook.step.js
    const config = {
      type: 'noop',
      name: 'Webhook Simulator',
      description: 'Simulates incoming webhook events',
      virtualEmits: ['webhook.received'],
      virtualSubscribes: [],
      flows: ['webhook-flow'],
    }

    module.exports = { config }
    ```
  </Tab>
</Tabs>

<Tabs items={['TS', 'JS']}>
  <Tab value="TS">
    ```typescript
    // test-webhook.step.tsx
    import React from 'react'
    import { BaseHandle, Position } from 'motia/workbench'

    export default function WebhookSimulator() {
      return (
        <div className="p-4 bg-gray-800 rounded-lg border border-gray-600 text-white">
          <div className="text-sm font-medium mb-2">Webhook Simulator</div>
          <button 
            onClick={() => {
              fetch('/api/webhook', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ event: 'test' }),
              })
            }}
            className="px-3 py-1 bg-blue-600 rounded text-sm"
          >
            Trigger Webhook
          </button>
          <BaseHandle type="source" position={Position.Bottom} />
        </div>
      )
    }
    ```
  </Tab>
  <Tab value="JS">
    ```javascript
    // test-webhook.step.jsx
    import React from 'react'
    import { BaseHandle, Position } from 'motia/workbench'

    export default function WebhookSimulator() {
      return (
        <div className="p-4 bg-gray-800 rounded-lg border border-gray-600 text-white">
          <div className="text-sm font-medium mb-2">Webhook Simulator</div>
          <button 
            onClick={() => {
              fetch('/api/webhook', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ event: 'test' }),
              })
            }}
            className="px-3 py-1 bg-blue-600 rounded text-sm"
          >
            Trigger Webhook
          </button>
          <BaseHandle type="source" position={Position.Bottom} />
        </div>
      )
    }
    ```
  </Tab>
</Tabs>

## Representing External Processes

NOOP steps represent parts of your workflow that happen outside your system. Common examples include:

### Webhook Callbacks

<Tabs  items={['TS', 'JS']}>
  <Tab value="TS">
    ```typescript
    export const config: NoopConfig = {
      type: 'noop',
      name: 'Wait for Stripe Webhook',
      description: 'Waits for payment confirmation',
      virtualSubscribes: ['payment.initiated'],
      virtualEmits: ['/api/stripe/webhook'],
      flows: ['payment'],
    }
    ```
  </Tab>
  <Tab value="JS">
    ```javascript
    const config = {
      type: 'noop',
      name: 'Wait for Stripe Webhook',
      description: 'Waits for payment confirmation',
      virtualSubscribes: ['payment.initiated'],
      virtualEmits: ['/api/stripe/webhook'],
      flows: ['payment'],
    }
    ```
  </Tab>
</Tabs>

### Human Approvals

<Tabs  items={['TS', 'JS']}>
  <Tab value="TS">
    ```typescript
    export const config: NoopConfig = {
      type: 'noop',
      name: 'Manager Review',
      description: 'Manager reviews request',
      virtualSubscribes: ['approval.requested'],
      virtualEmits: ['/api/approvals/submit'],
      flows: ['approval'],
    }
    ```
  </Tab>
  <Tab value="JS">
    ```javascript
    const config = {
      type: 'noop',
      name: 'Manager Review',
      description: 'Manager reviews request',
      virtualSubscribes: ['approval.requested'],
      virtualEmits: ['/api/approvals/submit'],
      flows: ['approval'],
    }
    ```
  </Tab>
</Tabs>

### External System Integration

<Tabs  items={['TS', 'JS']}>
  <Tab value="TS">
    ```typescript
      export const config: NoopConfig = {
        type: 'noop',
        name: 'GitHub Webhook',
        description: 'Waiting for repository events',
        virtualSubscribes: ['repository.watched'],
        virtualEmits: ['/api/github/webhook'],
        flows: ['repo-automation'],
      }
      ```
  </Tab>
  <Tab value="JS">
    ```javascript
    const config = {
      type: 'noop',
      name: 'GitHub Webhook',
      description: 'Waiting for repository events',
      virtualSubscribes: ['repository.watched'],
      virtualEmits: ['/api/github/webhook'],
      flows: ['repo-automation'],
    }
    ```
  </Tab>
</Tabs>

### Physical Processes

<Tabs  items={['TS', 'JS']}>
  <Tab value="TS">
    ```typescript
    export const config: NoopConfig = {
      type: 'noop',
      name: 'Order Fulfillment',
      description: 'Warehouse processes order',
      virtualSubscribes: ['order.placed'],
      virtualEmits: ['/api/warehouse/status'],
      flows: ['fulfillment'],
    }
    ```
  </Tab>
  <Tab value="JS">
    ```javascript
    const config = {
      type: 'noop',
      name: 'Order Fulfillment',
      description: 'Warehouse processes order',
      virtualSubscribes: ['order.placed'],
      virtualEmits: ['/api/warehouse/status'],
      flows: ['fulfillment'],
    }
    ```
  </Tab>
</Tabs>

## Visualization in Workbench

NOOP steps are visually represented in the Motia Workbench with the following characteristics:

- Distinct node representation with clear input/output handles
- Visual indicators for virtual event connections
- Status indicators for waiting states
- Clear visualization of external system dependencies

## Custom UI

You can enhance your NOOP steps with custom React components for better visualization:

<Tabs  items={['TS', 'JS']}>
  <Tab value="TS">
    ```tsx
    // customNode.step.tsx
    import React from 'react'
    import { BaseHandle, EventNodeProps, Position } from 'motia/workbench'

    export default (_: EventNodeProps) => {
      return (
        <div className="p-3 px-6 flex flex-col max-w-[300px] bg-blue-500 border-white rounded-full text-white border border-solid text-center text-sm">
          <div>Custom Processing</div>
          <BaseHandle type="target" position={Position.Top} />
          <BaseHandle type="source" position={Position.Bottom} />
        </div>
      )
    }

    // customNode.step.ts
    export const config: NoopConfig = {
      type: 'noop',
      name: 'Custom Process',
      virtualEmits: ['/api/process/complete'],
      virtualSubscribes: ['process.start'],
      flows: ['custom-flow']
    }
    ```
  </Tab>
  <Tab value="JS">
    ```jsx
    // customNode.step.jsx
    import React from 'react'
    import { BaseHandle, EventNodeProps, Position } from 'motia/workbench'

    export default (_: EventNodeProps) => {
      return (
        <div className="p-3 px-6 flex flex-col max-w-[300px] bg-blue-500 border-white rounded-full text-white border border-solid text-center text-sm">
          <div>Custom Processing</div>
          <BaseHandle type="target" position={Position.Top} />
          <BaseHandle type="source" position={Position.Bottom} />
        </div>
      )
    }

    // customNode.step.js
    const config = {
      type: 'noop',
      name: 'Custom Process',
      virtualEmits: ['/api/process/complete'],
      virtualSubscribes: ['process.start'],
      flows: ['custom-flow']
    }

    module.exports = {config};
    ```
  </Tab>
</Tabs>

## Best Practices

| Category | Guidelines |
|----------|------------|
| **File Organization** | • Keep configuration and UI code in separate files<br/>• Use `.step.ts` for configuration<br/>• Use `.step.tsx` for UI components |
| **UI Components** | • Use functional React components<br/>• Include proper TypeScript types<br/>• Follow Tailwind's utility classes<br/>• Keep components minimal and focused<br/>• Design clear visual connection points<br/>• Always include BaseHandle components for flow connections |
| **Configuration** | • Always include `virtualSubscribes` (even if empty)<br/>• Use descriptive names for virtual events<br/>• Include clear descriptions<br/>• Use descriptive, action-oriented names |
| **External Process Modeling** | • Document expected timeframes and SLAs<br/>• Define all possible outcomes and edge cases<br/>• Use exact API route matching |
| **Testing** | • Create isolated test flows<br/>• Use realistic test data<br/>• Handle errors gracefully<br/>• Implement clear status indicators<br/>• Label test steps explicitly<br/>• Provide visual feedback for actions |

## Component Reference

### Core Imports

| Import | Purpose |
|--------|---------|
| `BaseHandle` | A React component that renders connection points for nodes in the workflow. Used to define where edges (connections) can start or end on a node. |
| `EventNodeProps` | (TypeScript only) Interface defining the properties passed to node components, including node data, selected state, and connection information. |
| `Position` | (TypeScript only) Enum that specifies the possible positions for handles on a node (Top, Right, Bottom, Left). Used to control where connection points appear. |

### Handle Placement

| Handle Type | Position | 
|------------|----------|
| Input Handles | Position.Top |
| Output Handles | Position.Bottom |
| Flow Direction | Top to bottom |

### Styling Guidelines

| Category | Guidelines |
|----------|------------|
| Colors | Use semantic colors to indicate state (success, error, pending) |
| States | • Implement clear visual indicators for active/inactive states<br/>• Use subtle animations for state transitions |
| Design System | • Follow your project's design tokens<br/>• Maintain consistent spacing and padding<br/>• Use standard border radiuses<br/>• Ensure high contrast for readability<br/>• Use consistent font sizes (14px-16px) |


-   [Overview](/llm-docs/workbench/overview.md): Documentation for Overview.
---
title: Overview
---

Motia Workbench is a development platform that helps you build and debug your Motia flows. It serves as your control center where you can:

- Visualize flows as interactive diagrams
- Test steps directly in the UI
- Monitor real-time logs
- Debug issues

![Flow Visualization in Workbench](./../img/demo-workbench.png)

## Getting Started

Start workbench by running:

<Tabs items={['npm', 'yarn', 'pnpm', 'bun']}>
  <Tab value="pnpm">```pnpm run dev ```</Tab>
  <Tab value="yarn">```yarn run dev ```</Tab>
  <Tab value="npm">```npm run dev ```</Tab>
  <Tab value="bun">```bun run dev ```</Tab>
</Tabs>

<Callout>
  Running the dev command starts: - **Motia Server**: Backend services and API endpoints - **Motia Workbench**: Web
  interface at http://localhost:3000 - **Development Mode**: Auto-reloads when changes are made
</Callout>

## Key Features

<Steps>
  <Step>
  ### Flow Visualization
  See your entire flow as an interactive diagram:
  - Steps appear as connected nodes
  - API endpoints are highlighted as entry points
  - Event connections show data flow
  - Click any step to see its details
  </Step>

<Step>
  ### Real-time Testing Test your flows directly in the interface: - Send test requests to API endpoints - Monitor how
  events flow through steps - Visualize step sequence execution - Inspect data at each stage
</Step>

<Step>
  ### Live Logs Monitor your flow execution: ``` [INFO] [payment-flow] Payment received: $50.00 [DEBUG] [payment-flow]
  Processing payment... ```
</Step>

  <Step>
   ### Development Tools
  - **Hot Reload**: Changes reflect immediately in the UI
  - **Error Handling**: Detailed error messages with contextual debugging information
  - **State Inspector**: Real-time monitoring of state management
  </Step>
</Steps>

## Customization

Motia Workbench allows you to customize how your steps appear in the Workbench flow visualization tool.

### NOOP Steps

NOOP (No Operation) steps represent virtual points in your flow where external actions occur:

- Human approvals or reviews
- Webhook callbacks
- External system integrations
- Manual interventions

These steps help visualize important external touchpoints without implementing actual logic.

### UI Steps

UI steps allow you to customize how your steps appear in the Workbench visualization:

- Override the default layout of Event steps
- Customize API endpoint representations
- Modify how Cron jobs are displayed
- Add custom icons and styling

<Breadcrumb
  items={[
    {
      name: 'UI Steps',
      url: '/docs/workbench/ui-steps',
    },
    {
      name: 'NOOP Steps',
      url: '/docs/workbench/noop-steps',
    },
  ]}
/>

<Callout>New to Motia? Follow the **[quick start](/docs/getting-started/quick-start)** guide to get set up.</Callout>


-   [UI Steps](/llm-docs/workbench/ui-steps.md): Documentation for UI Steps.
---
title: UI Steps
---

UI Steps provide a powerful way to create custom, visually appealing representations of your workflow steps in the Workbench flow visualization tool.

With UI Steps, you can enhance the user experience by designing intuitive, context-aware visual components that clearly communicate your flow's sequencing and events.

## Overview

To create a custom UI for a step, create a `.tsx` or `.jsx` file next to your step file with the same base name:

<Tabs items={['tsx', 'jsx']}>
  <Tab value="tsx">
    ``` 
    steps/ 
    └── myStep/ 
      ├── myStep.step.ts      # Step definition
      └── myStep.step.tsx     # Visual override
    ```
  </Tab>
  <Tab value="jsx">
    ```
    steps/
      └── myStep/
      ├── myStep.step.js      # Step definition
      └── myStep.step.jsx     # Visual override
    ```
  </Tab>
</Tabs>

## Basic Usage

Let's override an EventNode but keeping the same look. Like the image below.
We're going to add an image on the side and show the description.

![Custom Event Node](./../img/custom-event-node.png)

<Tabs items={['TypeScript', 'JavaScript']}>
  <Tab>
    ```tsx
    // myStep.step.tsx

    import { EventNode, EventNodeProps } from 'motia/workbench'
    import React from 'react'

    export const Node: React.FC<EventNodeProps> = (props) => {
      return (
        <EventNode {...props}>
          <div className="flex flex-row items-start gap-2">
            <div className="text-sm text-gray-400 font-mono">{props.data.description}</div>
            <img
              style={{ width: '64px', height: '64px' }}
              src="https://www.motia.dev/icon.png"
            />
          </div>
        </EventNode>
      )
    }
    ```

  </Tab>
  <Tab>
    ```jsx
    // myStep.step.jsx

    import { EventNode } from 'motia/workbench'
    import React from 'react'

    export const Node = (props) => {
      return (
        <EventNode {...props}>
          <div className="flex flex-row items-start gap-2">
            <div className="text-sm text-gray-400 font-mono">{props.data.description}</div>
            <img
              style={{ width: '64px', height: '64px' }}
              src="https://www.motia.dev/icon.png"
            />
          </div>
        </EventNode>
      )
    }
    ```

    

  </Tab>
</Tabs>

## Components

Motia Workbench provides out of the box components that you can use to create custom UI steps, which apply to different types of steps.


| Component   | Props Type     | Description                                                                    |
| ----------- | -------------- | ------------------------------------------------------------------------------ |
| EventNode   | EventNodeProps | Base component for Event Steps, with built-in styling and connection points    |
| ApiNode     | ApiNodeProps   | Component for API Steps, includes request/response visualization capabilities  |
| CronNode    | CronNodeProps  | Base component for Cron Steps, displays timing information                     |
| NoopNode    | NoopNodeProps  | Base component for NoopNodes with a different color to comply workbench legend |

## Customizing completely

You can also fully customize your node making it look completely different from the result.
Let's draw the following node.

![Custom Ideator Agent Node](./../img/custom-ideator-agent-node.png)

```tsx
import { BaseHandle, EventNodeProps, Position } from 'motia/workbench'
import React from 'react'

export const Node: React.FC<EventNodeProps> = (props) => {
  return (
    <div className="w-80 bg-black text-white rounded-xl p-4">
      <div className="group relative">
        <BaseHandle type="target" position={Position.Top} variant="event" />

        <div className="flex items-center space-x-3">
          <img className="w-8 h-8" src="https://cdn-icons-png.flaticon.com/512/12222/12222588.png" />
          <div className="text-lg font-semibold">{props.data.name}</div>
        </div>

        <div className="mt-2 text-sm font-medium text-gray-300">{props.data.description}</div>

        <div className="mt-3 flex flex-col gap-2 border border-gray-800 border-solid p-2 rounded-md w-full">
          <div className="flex items-center text-xs text-gray-400 space-x-2">Input</div>
          <div className="flex flex-col gap-2 whitespace-pre-wrap font-mono">
            <div className="flex items-center gap-2">
              <div className="">contentIdea:</div>
              <div className="text-orange-500">string</div>
            </div>
            <div className="flex items-center gap-2">
              <div className="">contentType:</div>
              <div className="text-orange-500">string</div>
            </div>
          </div>
        </div>

        <div className="mt-3 flex flex-col gap-2 border border-gray-800 border-solid p-2 rounded-md w-full">
          <div className="flex items-center text-xs text-gray-400 space-x-2">Output</div>
          <div className="flex flex-col gap-2 whitespace-pre-wrap font-mono">
            <div className="flex items-center gap-2">
              <div className="">topic:</div>
              <div className="text-orange-500">string</div>
            </div>
            <div className="flex items-center gap-2">
              <div className="">subtopics:</div>
              <div className="text-orange-500">string[]</div>
            </div>
            <div className="flex items-center gap-2">
              <div className="">keywords:</div>
              <div className="text-orange-500">string[]</div>
            </div>
            <div className="flex items-center gap-2">
              <div className="">tone:</div>
              <div className="text-orange-500">string</div>
            </div>
            <div className="flex items-center gap-2">
              <div className="">audience:</div>
              <div className="text-orange-500">string</div>
            </div>
          </div>
        </div>

        <BaseHandle type="source" position={Position.Bottom} variant="event" />
      </div>
    </div>
  )
}
```

### Important Notes

- You will need to add `<BaseHandle>` to your node, otherwize it won't show the connectors.
- If your node has padding, make sure to add a group inside your node with class `group relative` so the handles can be correctly positioned.

<Callout type="info">Feel free to create your own custom components and reuse across multiple notes.</Callout>

## Styling Guidelines

| Guideline                           | Description                                                   |
| ----------------------------------- | ------------------------------------------------------------- |
| Use Tailwind's utility classes only | Stick to Tailwind CSS utilities for consistent styling        |
| Avoid arbitrary values              | Use predefined scales from the design system                  |
| Keep components responsive          | Ensure UI elements adapt well to different screen sizes       |
| Follow Motia's design system        | Maintain consistency with Motia's established design patterns |



## Best Practices

| Practice             | Description                                 |
| -------------------- | ------------------------------------------- |
| Use base components  | Use `EventNode` and `ApiNode` when possible |
| Keep it simple       | Maintain simple and clear visualizations    |
| Optimize performance | Minimize state and computations             |
| Documentation        | Document custom components and patterns     |
| Style sharing        | Share common styles through utility classes |



## Optional
-   [https://motiadev.com](https://motiadev.com): Main page for framework.
-   [Github repo](https://github.com/motiadev/motia): Main github repository to file issues.
