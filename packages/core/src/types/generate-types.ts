import { isApiStep, isCronStep, isEventStep } from '../guards'
import { Printer } from '../printer'
import { Emit, Step } from '../types'
import { Stream } from '../types-stream'
import { generateTypeFromSchema } from './generate-type-from-schema'
import { generateTypesFromResponse } from './generate-types-from-response'
import { mergeSchemas } from './merge-schemas'
import { JsonSchema } from './schema.types'

type HandlersMap = Record<string, { type: string; generics: string[] }>
type StreamsMap = Record<string, string>

export const generateTypesString = (handlers: HandlersMap, streams: StreamsMap): string => {
  return `/**
 * Automatically generated types for motia
 * Do NOT edit this file manually.
 * 
 * Consider adding this file to .prettierignore and eslint ignore.
 */
import { EventHandler, ApiRouteHandler, ApiResponse, MotiaStream } from 'motia'

declare module 'motia' {
  interface FlowContextStateStreams {
    ${Object.entries(streams)
      .map(([key, value]) => `'${key}': MotiaStream<${value}>`)
      .join('\n    ')
      .trim()}
  }

  type Handlers = {
    ${Object.entries(handlers)
      .map(([key, { type, generics }]) => `'${key}': ${type}<${generics.join(', ')}>`)
      .join('\n    ')
      .trim()}
  }
}`
}

export const generateTypesFromSteps = (steps: Step[], printer: Printer): HandlersMap => {
  const handlers: HandlersMap = {}
  const topics: Record<string, string> = {}
  const topicsSchemas: Record<string, JsonSchema> = {}
  const topicsSteps: Record<string, Step[]> = {}

  for (const step of steps) {
    if (isEventStep(step) && step.config.input) {
      for (const topic of step.config.subscribes) {
        const existingSchema = topicsSchemas[topic]

        topicsSteps[topic] = topicsSteps[topic] ?? []
        topicsSteps[topic].push(step)

        try {
          const input = step.config.input as never as JsonSchema
          const schema = existingSchema ? mergeSchemas(existingSchema, input) : input
          topics[topic] = generateTypeFromSchema(schema)
          topicsSchemas[topic] = schema
        } catch (error) {
          printer.printInvalidSchema(topic, topicsSteps[topic])
          // invalid schema, the topic should be ignored
          topics[topic] = 'never'
        }
      }
    }
  }

  const generateEmitData = (emit: Emit[]): string => {
    const emits = emit
      .reduce((acc, emit) => {
        const topic = typeof emit === 'string' ? emit : emit.topic
        const topicType = topics[topic]

        if (topicType) {
          acc.push(`{ topic: '${topic.replace(/'/g, "\\'")}'; data: ${topicType} }`)
        }

        return acc
      }, [] as string[])
      .join(' | ')

    return emits.length === 0 ? 'never' : emits
  }

  for (const step of steps) {
    const emits = 'emits' in step.config ? generateEmitData(step.config.emits) : 'never'

    if (isEventStep(step)) {
      const input = step.config.input ? generateTypeFromSchema(step.config.input as never as JsonSchema) : 'never'
      handlers[step.config.name] = { type: 'EventHandler', generics: [input, emits] }
    } else if (isApiStep(step)) {
      const input = step.config.bodySchema
        ? generateTypeFromSchema(step.config.bodySchema as never as JsonSchema)
        : 'Record<string, unknown>'
      const result = step.config.responseSchema
        ? generateTypesFromResponse(step.config.responseSchema as never as Record<number, JsonSchema>)
        : 'unknown'
      handlers[step.config.name] = { type: 'ApiRouteHandler', generics: [input, result, emits] }
    } else if (isCronStep(step)) {
      handlers[step.config.name] = { type: 'CronHandler', generics: [emits] }
    }
  }

  return handlers
}

export const generateTypesFromStreams = (streams: Record<string, Stream>): StreamsMap => {
  return Object.entries(streams).reduce((acc, [key, stream]) => {
    if (!stream.hidden) {
      acc[key] = generateTypeFromSchema(stream.config.schema as unknown as JsonSchema)
    }
    return acc
  }, {} as StreamsMap)
}
